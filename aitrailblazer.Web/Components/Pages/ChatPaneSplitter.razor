@rendermode InteractiveServer
@using Microsoft.AspNetCore.Hosting
@using Microsoft.Identity.Web
@using AITrailblazer.net.Services
@using AITrailblazer.net.Models
@using System.ComponentModel.DataAnnotations
@using Microsoft.AspNetCore.Authorization
@using Microsoft.Identity.Web
@using AITGraph.Sdk.Models
@using System.Text.Json
@using System.Text.Json.Serialization
@using Newtonsoft.Json
@using System.Text
@using Markdig
@using OntologyTreeApp.Models
@inject AITGraphService GraphService
@inject NavigationManager Navigation
@inject ILogger<User> Logger
@inject AITGraphService graphService


@inject PluginService PluginService

@inject AzureOpenAIHandler azureOpenAIHandler

@inject AICopilotSettingsService AICopilotSettings

@inject AgentConfigurationService _agentConfigurationService
@inject IJSRuntime JSRuntime
@implements IAsyncDisposable
@displayName
@userEmail
@timeZoneInfo
@currentUserIdentityID
<FluentTabs @bind-ActiveTabId="@activeid1" OnTabChange="HandleOnMainTabChange" Class="top-tabs-font-size">
    <FluentTab Id="Work-id">
        <Header>
            Work
        </Header>
           <Content>
            </Content>
    </FluentTab>
     <FluentTab Id="Reference-id">
    <Header>
        Reference
    </Header>
        <Content>
        </Content>
    </FluentTab>
</FluentTabs> 

@code {
    [Parameter]
    public string FeatureNameProject { get; set; } = "AIWriting";

   [Parameter]
    public string FeatureUserFriendlyName { get; set; } = "AI Writing Assistant";
    
    [Parameter]
    public string FeatureDescription { get; set; } = "AIWriting";

   [Parameter]
    public string? TemplateName { get; set; }
   
   [Parameter]
    public bool IsProject { get; set; }  = false;
    
    [Parameter]
    public string RawDataOntologies { get; set; } = "";

    [Parameter]
    public string PanelInput { get; set; } = "";

    //[Parameter]
    //public Session? CurrentSession { get; set; }

    [Parameter]
    public EventCallback OnNavBarVisibilityUpdated { get; set; }

    [Parameter]
    public EventCallback<string> OnChatUpdated { get; set; }
        
    [Parameter]  
    public EventCallback<string> OnUserInputSubmit { get; set; }

    [Parameter]  
    public bool showLEFTPane  { get; set; } = false;
        
    [Parameter]  
    public bool showINPUTPane  { get; set; } = true;
    
    [Parameter]
    public string? currentUserIdentityID   { get; set; }

    [Parameter]
    public string? userEmail   { get; set; }
    
    [Parameter]
    public string? displayName   { get; set; }
 
    [Parameter]
    public string? timeZoneInfo   { get; set; }

    [Parameter]
    public string? c { get; set; }

       [Parameter]
    public EventCallback<string> OnFeatureNameChanged { get; set; }
    
    private FileItemRow _selectedFile;
    
    [Parameter]
    public FileItemRow SelectedFile
    {
        get => _selectedFile;
        set
        {
            if (_selectedFile != value)
            {
                _selectedFile = value;

                if (_selectedFile != null)
                {
                }
                else
                {
                    // Clear the OntologyTree if SelectedFile is null
                    OntologyTree = null;
                }
            }
        }
    }
     private string _selectedFileContent;

    [Parameter]
    public string SelectedFileContent
    {
        get => _selectedFileContent;
        set
        {
            if (_selectedFileContent != value)
            {
                _selectedFileContent = value;

                if (!string.IsNullOrWhiteSpace(_selectedFileContent))
                {
                    // Parse the content only if SelectedFileContent is not null or empty
                    OntologyTree = ParseOntologyTreeMarkdown(_selectedFileContent);
                    //Console.WriteLine($"SelectedFile OntologyTree: {_selectedFileContent}");
                }
                else
                {
                    // Clear the OntologyTree if SelectedFileContent is null or empty
                    OntologyTree = null;
                    Console.WriteLine("SelectedFileContent is empty, clearing OntologyTree");
                }

                // Trigger a re-render
                StateHasChanged();
            }
        }
    }


    private bool isLeftPaneCollapsed = false;
    private bool isRightPaneCollapsed = false;

    private bool isHtmlView = false;
    public string RequestFeatureNameWorkflowName { get; set; } = "";
    public string RequestFeatureNameProject { get; set; } = "";

    private string LeftPaneSize => isLeftPaneCollapsed ? "40px" : CalculateLeftPaneSize();
    private string FluentCardWidth => CalculateFluentCardWidth();
    private string MiddlePaneSize => CalculateMiddlePaneSize();
    private string RightPaneSize => isRightPaneCollapsed ? "40px" : "20%";
    
    private string CalculateLeftPaneSize()
    {
        return activeid switch
        {
            "Github-id" => "20%", // Adjust this value based on your preference
            "ConversationalMemory-id" => "20%", // Default size for Sessions
            _ => "20%", // Fallback size
        };
    }
    private string CalculateFluentCardWidth()
    {
        return activeid switch
        {
            "Github-id" => "820px", // Wide width for Github Repositories
            "ConversationalMemory-id" => "340px", // Narrow width for Sessions
            _ => "340px", // Fallback width
        };
    }
        private string CalculateMiddlePaneSize()
        {
            if (isLeftPaneCollapsed && isRightPaneCollapsed) return "calc(100% - 80px)";
            if (isLeftPaneCollapsed) return "calc(100% - 30px - 15%)"; // 15% for right pane and 30px for collapsed left pane
            if (isRightPaneCollapsed) return "calc(100% - 20% - 30px)"; // 20% for left pane and 30px for collapsed right pane
            return "calc(100% - 20% - 15% - 60px)"; // 20% for left pane, 15% for right pane, and 60px for both panes
        }

    private void ToggleLeftPane()
    {
        isLeftPaneCollapsed = !isLeftPaneCollapsed;
    }
    private void ToggleRightPane()
    {
        isRightPaneCollapsed = !isRightPaneCollapsed;
    }
    private bool isShowFullAgentsChatThreadVisible = false;
    public string CurrentFeatureWorkflowName { get; set; } = "Writing";

    public string CurrentFeatureName { get; set; } = "AIWritingAssistant";
    //public string CurrentTaskWorkflowName { get; set; } = "Current Task";

    string masterTextSetting = "Ask"; // Ask, Correct, Improve, Content
    string ChatSetting = "OneShot"; // OneShot
    
    private Profile profile;
    private UserAccountInformation accountInfo;

    string ImageSetting = "Photo"; //
    private string DBKey = null;

    bool oneShotSetting = true;
    string UserInput = "";
    string UserInputSaved = "";

    public bool Autofocus { get; set; } = true;
    private bool submitting = false;

    private FluentTreeItem? currentSelectedTreeItemAICopilotSettings = null;
    private FluentTreeItem? currentSelectedTreeItemAICopilots = null;

    public string PlaceholderInputText { get; set; } = "Please enter lengthy texts or code in this space.\nEnter your prompt into the Prompt/Command Line below.";
    public string PlaceholderOutputText { get; set; } = "The AI will display the processed output here for your review and analysis.";

    public string PlaceholderCommandText { get; set; } = "Ask AI Assistant.";

    public int Rows = 24;
    public int RowsCommand = 12;

    string PanelInputTemp = null;

    private string PanelOutputFinal { get; set; } = "";

    private string ProcessedPanelOutputFinal { get; set; }

    private MarkupString ProcessedPanelOutputFinalHTML { get; set; } = (MarkupString)string.Empty;


    public string PanelOutput { get; set; } = "";
    
    private bool IsDarkMode { get; set; } = false;

    private string ProcessedPanelOutput { get; set; }

    private MarkupString ProcessedPanelOutputHTML { get; set; } = (MarkupString)string.Empty;

    private string RecipientEmails { get; set; }

    private bool PanelOutputSwitchValue { get; set; } =false;

    private bool PanelOutputFinalSwitchValue { get; set; } =false;


    private string? UserPromptSet { get; set; }
    private string? CollectionName { get; set; }
    private string? imageUrl;
    //private List<SessionMessage>? _messagesInChat;
    //private static event EventHandler<Session>? _onMessagePosted;
    private bool _loadingComplete;
    string? comboboxValue;
    string InputMessage = "";
    string ResultMessage = "";
    public string FeatureNamePipeline { get; set; } = "";
    public string FeatureFriendlyNameCurrent { get; set; } = "";
    bool useVectorSearch = false;

    string callFunctionTemp = "";

    private string topicType = "";

    private string backdropType = "";//
    private string backdropTypeDescription = "";
    private string lightingType = "";//
    private string lightingTypeDescription = "";//

    private string photostyleType = "";//
    private string photostyleTypeDescription = "";//

    private string photoshotType = "";//
    private string photoshotTypeDescription = "";//

    private string imageContentType = "Art";// Photo, Graphic, Art
    private string imageSize = "Landscape"; // Square=1024x1024, Landscape=1024x1792 or Vertical=1792x1024
    private string imageGenerationQuality = "High Definition"; // Normal, High Definition


    bool webSearchUse = false;
    bool IsMyKnowledgeBaseChecked = false;

    private string pluginDir = "";
    string imageSettingMenu = "Text To Photo";

    private string imageGenerationStyle = "Vivid"; // Standard, Vivid

    private string pastedImageBase64 = string.Empty;

    private string imageBase64 = string.Empty;

    private List<DiagramOption> diagramOptions = new();
    private DiagramOption selectedDiagramOption;
    private string selectedDiagramValue;
    List<MenuItemOneLevel> menuItemsDiagrams = new List<MenuItemOneLevel>();
    public string FeatureName { get; set; } = null;

    public string FeatureName1 { get; set; } = null;
    public string FeatureName2 { get; set; } = null;
    public string FeatureName3 { get; set; } = null;
    private void HandleTagsChange(string newTags)
    {
        Tags = newTags; // Update the tags
        Console.WriteLine($"Tags: {Tags}");
    }

    public async ValueTask DisposeAsync()
    {
        // Implement any cleanup logic here if needed
        await ValueTask.CompletedTask;
    }
}

@code{
        private async Task HandleMasterTextSettingRadioChange(string newSetting)
    {
        var newSettingCommandPlaceholder = MasterTextSettingsService.CreateCommandPlaceholderForMasterTextSetting(newSetting);

        masterTextSetting = newSetting;
        Console.WriteLine($"MasterTextSetting: {masterTextSetting}");
        if (masterTextSetting == "Help")
        {
            PlaceholderCommandText = $"Ask to {newSettingCommandPlaceholder}";
        } else if (masterTextSetting == "Ask"){
            PlaceholderCommandText = $"Ask {CurrentFeatureName} to {newSettingCommandPlaceholder}";

        } else if (masterTextSetting == "Correct"){
            PlaceholderCommandText = $"Ask {CurrentFeatureName} to {newSettingCommandPlaceholder}";

        } else if (masterTextSetting == "Improve"){
            PlaceholderCommandText = $"Ask {CurrentFeatureName} to {newSettingCommandPlaceholder}";

        } else if (masterTextSetting == "Content"){
            PlaceholderCommandText = $"Ask {CurrentFeatureName} to {newSettingCommandPlaceholder}";

        }       
        await Task.CompletedTask;
    }
    private async Task HandleMyKnowledgeBaseCheckedChange(bool isChecked)
    {
        IsMyKnowledgeBaseChecked = isChecked;
        Console.WriteLine($"IsMyKnowledgeBaseChecked: {IsMyKnowledgeBaseChecked}");
    }
    private async Task HandleChatSettingRadioChange(ChatSettings settings)
    {
        ChatSetting = settings.ChatSetting;
        oneShotSetting = settings.OneShotSetting;
        //ChatSettingRadioChangeResultMessage = $"Chat setting: {settings.ChatSetting}, One-shot: {settings.OneShotSetting}";
        // ChatSetting: OneShot
        // ChatSetting: Pipeline
        Console.WriteLine($"ChatSetting: {ChatSetting}");

        if (ChatSetting == "Workflow")
        {
            UserInputSaved = UserInput;
            string CurrentSessionId = $"{CurrentSession.Id}"; 
            string workflow = await azureOpenAIHandler.LoadSessionMessagesPipeAsync(CurrentSessionId);
            //Console.WriteLine($"LoadSessionMessagesAsync userFriendlyText: {userFriendlyText}");
            UserInput=($"Workflow: {workflow}");
        } else{
            UserInput=UserInputSaved;
            //currentSelectedTreeItemAICopilots  = null;
            await InvokeAsync(StateHasChanged);
        }
        await Task.CompletedTask;
    }
    public string PipeDelimited()
    {
        string pipeDelimitedString = string.Join("|", 
            //currentUserIdentityID, 
            //CurrentFeatureName, 
            //PanelInput, 
            //userInput, 
            masterTextSetting, 
            ChatSetting,
            AICopilotSettings.WritingStyleVal, 
            AICopilotSettings.AudienceLevelVal, 
            AICopilotSettings.ResponseLengthVal, 
            AICopilotSettings.CreativeAdjustmentsVal, 
            AICopilotSettings.RelationSettingsVal, 
            AICopilotSettings.ResponseStyleVal
        );
        return pipeDelimitedString;
    }
    public void  AICopilotSettingsReset()
    {
        AICopilotSettings.WritingStyleVal = ""; 
        AICopilotSettings.AudienceLevelVal= ""; 
        AICopilotSettings.ResponseLengthVal= "1024"; 
        AICopilotSettings.CreativeAdjustmentsVal= "Focused"; 
        AICopilotSettings.RelationSettingsVal= ""; 
        AICopilotSettings.ResponseStyleVal= ""; 
    }
    bool isNewSession = true;
    private string GetFormattedSessionTitle(string text)
    {
        // Count the number of dashes in the text
        int dashCount = text.Count(c => c == '-');

        // Only remove the date part if there are at least 2 dashes
        if (dashCount >= 2)
        {
            // Assuming the date is always in the format "yyyyMMdd-HHmmss-"
            int dateEndIndex = text.IndexOf('-', text.IndexOf('-') + 1) + 1;
            if (dateEndIndex < text.Length)
            {
                text = text.Substring(dateEndIndex);
            }
        }

        // Return the processed text, truncated if necessary
        return text.Length > 22 ? text.Substring(0, 22) : text;
    }
    private string GetFormattedSessionFullTitle(string text)
    {
        // Count the number of dashes in the text
        int dashCount = text.Count(c => c == '-');

        // Only remove the date part if there are at least 2 dashes
        if (dashCount >= 2)
        {
            // Assuming the date is always in the format "yyyyMMdd-HHmmss-"
            int dateEndIndex = text.IndexOf('-', text.IndexOf('-') + 1) + 1;
            if (dateEndIndex < text.Length)
            {
                text = text.Substring(dateEndIndex);
            }
        }

        // Return the processed text, truncated if necessary
        return  text;
    }

    public List<ChatMessageM> ChatMessages { get; set; } = new();
    //private string FinalContent { get; set; }

    private async Task HandleSubmit()
    {
        string userInput = UserInput;
        string panelInput = PanelInput;

        submitting = true;
        @if (selectedSectionContentFinal != null)
        {
            panelInput = "Reference: " + selectedSectionContentFinal + "\n\n" + panelInput+ "\n\n" ;
        }
        Console.WriteLine($"HandleSubmit userInput: {userInput}");
        Console.WriteLine($"HandleSubmit sessionSelectedName {sessionSelectedName}");
        if (SelectedFile != null)
        {
            panelInput = SelectedFileContent + "\n\n" + panelInput;
        }
        // Concatenate values into a pipe-delimited string
        string pipeDelimitedString = string.Join("|",
            currentUserIdentityID,
            CurrentFeatureWorkflowName,
            CurrentFeatureName,
            panelInput,
            userInput,
            masterTextSetting,
            AICopilotSettings.ResponseLengthVal,
            AICopilotSettings.CreativeAdjustmentsVal,
            AICopilotSettings.AudienceLevelVal,
            AICopilotSettings.WritingStyleVal,
            AICopilotSettings.RelationSettingsVal,
            AICopilotSettings.ResponseStyleVal
        );

        // Get the output from AzureOpenAIHandler
        PanelOutput = await azureOpenAIHandler.HandleSubmitAsync(
            isNewSession,
            IsMyKnowledgeBaseChecked,
            currentUserIdentityID,
            CurrentFeatureWorkflowName,
            CurrentFeatureName,
            panelInput,
            userInput,
            Tags,
            masterTextSetting,
            AICopilotSettings.ResponseLengthVal,
            AICopilotSettings.CreativeAdjustmentsVal,
            AICopilotSettings.AudienceLevelVal,
            AICopilotSettings.WritingStyleVal,
            AICopilotSettings.RelationSettingsVal,
            AICopilotSettings.ResponseStyleVal,
            sessionSelectedName
        );
        submitting = false;
        agentSettings = _agentConfigurationService.GetAgentSettings(CurrentFeatureName);

        if (agentSettings != null)
        {
            // Retrieve agent settings for the given project feature

            try
            {
                // Parse the JSON response into a list of messages
                ChatMessages = Newtonsoft.Json.JsonConvert.DeserializeObject<List<ChatMessageM>>(PanelOutput);

                // Format the final CopyWriter content with more prominent styling
                if (!string.IsNullOrEmpty(agentSettings.EditorRoleName)) {
                    PanelOutput = FormatProminentWriterContent(
                        ChatMessages.LastOrDefault(m => m.Author == agentSettings.EditorRoleName)?.Content ?? "No message from CopyWriter found."
                    );
                } else {
                    PanelOutput = FormatProminentWriterContent(
                        ChatMessages.LastOrDefault(m => m.Author == agentSettings.WriterRoleName)?.Content ?? "No message from CopyWriter found."
                    );
                }
            }
            catch (Newtonsoft.Json.JsonSerializationException ex)
            {
                Console.WriteLine($"Error deserializing response JSON: {ex.Message}");
                PanelOutput = "Failed to process the response. Please try again later.";
            }
        }

        await LoadSessionsAsync();
    }
  private async Task LoadSessionsAsync()
    {
        string directory = "Sessions";
        Sessions = await azureOpenAIHandler.LoadSessionsAsync(
            currentUserIdentityID, 
            directory);

        ItemsSessions = Sessions.Select(session => new TreeViewItem
        {
            Text = session.Name,
            Id = session.Id,
            OnExpandedAsync = OnExpandedAsync,
            Expanded = false, // Start with the session collapsed
            Items = TreeViewItem.LoadingTreeViewItems, // Placeholder for lazy loading
        }).Cast<ITreeViewItem>().ToList();

        if (ItemsSessions.Any())
        {
            CurrentSession = Sessions.Last();
            SelectedItem = ItemsSessions.Last();
            Console.WriteLine($"LoadSessionsAsync: CurrentSession Id {CurrentSession.Id}");
            Console.WriteLine($"LoadSessionsAsync: CurrentSession Name {CurrentSession.Name}");
            sessionSelectedName = CurrentSession.Name;
            // Automatically expand the last session
            await ExpandAndSelectLastChatInSessionAsync(CurrentSession.Id);
                
        } else {
            sessionSelectedName = null;
        }
 
        //StateHasChanged();
    }
    private async Task ExpandAndSelectLastChatInSessionAsync(string sessionId)
    {
        // Find the corresponding TreeViewItem for the session
        var sessionItem = ItemsSessions.FirstOrDefault(item => item.Id == sessionId);
        if (sessionItem != null)
        {
            // Manually trigger the loading of the session's messages
            sessionItem.Items = await azureOpenAIHandler.LoadSessionMessagesAsync(sessionId);
            
            // Set the session to be expanded
            sessionItem.Expanded = true;

        // Select the last chat item if available
            var lastChatItem = sessionItem.Items.LastOrDefault();
            if (lastChatItem != null)
            {
                HandleSelectedSessionItemChanged(lastChatItem);
            }
        }
    }

    private async Task OnExpandedAsync(TreeViewItemExpandedEventArgs e)
    {
        if (e.Expanded)
        {
            // 54a15dce-218d-4889-842f-4709a86704ed-AIWritingAssistant/ChatSession-Unified Workspace: Seamless Integration of Applications and AI Tools
            Console.WriteLine($"OnExpandedAsync e.CurrentItem.Id: {e.CurrentItem.Id}");

            // Load session messages when the item is expanded
            e.CurrentItem.Items = await azureOpenAIHandler.LoadSessionMessagesAsync(e.CurrentItem.Id);
        }
        else
        {
            // Use placeholder for collapsing
            e.CurrentItem.Items = TreeViewItem.LoadingTreeViewItems;
        }

        // Trigger UI update
        //StateHasChanged();
    }

    string sessionSelectedName;
    private void HandleSelectedSessionItemChanged(ITreeViewItem item)
    {
        if (item != null){
            var sessionSelected = Sessions.FirstOrDefault(s => s.Id == item.Id);
            // When clciking on the session
            if (sessionSelected != null)
            {
                sessionSelectedName = sessionSelected.Name;
                //Console.WriteLine($"HandleSelectedSessionItemChanged: sessionSelected.Id {sessionSelected.Id}");
                Console.WriteLine($"HandleSelectedSessionItemChanged: sessionSelectedName {sessionSelectedName}");
            }
            SelectedItem = item;
            // when clicking on the item, load the session messages
            OnItemSelectedAsync(item).ConfigureAwait(false);
            isNewSession = false;
        }
    }
    private async Task OnItemSelectedAsync(ITreeViewItem selectedItem)
    {
        // OnItemSelectedAsync: 54a15dce-218d-4889-842f-4709a86704ed-AIMessageOptimizer/ChatSession-20240825-063041-Optimizing Marketing Messages for Engagement and Conversion|Request-20240825-071724.json|Response-20240825-071724.json
        Console.WriteLine($"OnItemSelectedAsync: {selectedItem.Id}");

        // Split the selectedItem.Id into parts
        var sessionIdParts = selectedItem.Id.Split('|');
        if (sessionIdParts.Length != 3)
        {
            Console.WriteLine("Error: Unable to parse selectedItem.Id correctly.");
            return;
        }

        // sessionDirectoryPath: 54a15dce-218d-4889-842f-4709a86704ed-Sessions/ChatSession-20240903-010923-AI Driven Automation for Business Workflows
        // requestFileName: Request-20240903-010923-Writing-AIWritingAssistant-ASAPAutonomous Systems and Proce.json
        // responseFileName: Response-20240903-010923-Writing-AIWritingAssistant-ASAPAutonomous Systems and Proce.json
        string sessionDirectoryPath = sessionIdParts[0];
        string requestFileName = sessionIdParts[1];
        string responseFileName = sessionIdParts[2];

        Console.WriteLine($"sessionDirectoryPath: {sessionDirectoryPath}");
        Console.WriteLine($"requestFileName: {requestFileName}");
        Console.WriteLine($"responseFileName: {responseFileName}");

        // Split the sessionDirectoryPath into parts
        string[] pathParts = sessionDirectoryPath.Split('/');
        if (pathParts.Length < 2)
        {
            Console.WriteLine("Error: sessionDirectoryPath does not have the expected format.");
            return;
        }

        // Extract userId and directory
        string userIdAndDirectory = pathParts[0]; // 54a15dce-218d-4889-842f-4709a86704ed-Sessions
        int separatorIndex = userIdAndDirectory.LastIndexOf('-');
        if (separatorIndex == -1)
        {
            Console.WriteLine("Error: Unable to extract userId and directory from sessionDirectoryPath.");
            return;
        }

        string userId = userIdAndDirectory.Substring(0, separatorIndex);
        string directory = userIdAndDirectory.Substring(separatorIndex + 1);

        // Extract sessionDirectory
        string sessionDirectory = string.Join("/", pathParts.Skip(1));

        // userId: 54a15dce-218d-4889-842f-4709a86704ed
        // directory: Sessions
        //sessionDirectory: ChatSession-20240903-010923-AI Driven Automation for Business Workflows
        Console.WriteLine($"userId: {userId}");
        Console.WriteLine($"directory: {directory}");
        Console.WriteLine($"sessionDirectory: {sessionDirectory}");

        // Clean up session name by removing "ChatSession-" prefix if needed
        sessionSelectedName = sessionDirectory.Replace("ChatSession-", "");

        string requestContent;
        try
        {
            requestContent = await azureOpenAIHandler.ReadBlobContentAsync(
                userId, 
                directory, 
                sessionDirectory, 
                requestFileName);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error reading request blob content: {ex.Message}");
            return;
        }

        Console.WriteLine($"Raw request content: {requestContent}");

        if (string.IsNullOrWhiteSpace(requestContent))
        {
            Console.WriteLine("Error: Request content is null or empty.");
            PanelInput = string.Empty;
            return;
        }

        try
        {
            var requestData = Newtonsoft.Json.JsonConvert.DeserializeObject<RequestData>(requestContent);
            if (requestData == null)
            {
                Console.WriteLine("Error: Deserialized requestData is null.");
                PanelInput = string.Empty;
                return;
            }

            RequestFeatureNameWorkflowName = requestData.FeatureNameWorkflowName ?? string.Empty;
            RequestFeatureNameProject = requestData.FeatureNameProject ?? string.Empty;

            // Set the fields based on the deserialized requestData
            PanelInput = requestData.PanelInput?.Trim() ?? string.Empty;
            UserInput = requestData.Input?.TrimStart() ?? string.Empty;

            AICopilotSettings.ResponseLengthVal = requestData.ResponseLength ?? string.Empty;
            AICopilotSettings.CreativeAdjustmentsVal = requestData.CreativeAdjustments ?? string.Empty;
            AICopilotSettings.AudienceLevelVal = requestData.AudienceLevel ?? string.Empty;
            AICopilotSettings.WritingStyleVal = requestData.WritingStyle ?? string.Empty;
            AICopilotSettings.RelationSettingsVal = requestData.RelationSettings ?? string.Empty;
            AICopilotSettings.ResponseStyleVal = requestData.ResponseStyle ?? string.Empty;

            Console.WriteLine("Request data successfully extracted and set.");

        }
        catch (System.Text.Json.JsonException ex)
        {
            Console.WriteLine($"Error parsing JSON: {ex.Message}");
            PanelInput = string.Empty;
            return;
        }
        CurrentFeatureName=RequestFeatureNameProject;
        // Read and process the response content
        string responseContent;
        try
        {
            responseContent = await azureOpenAIHandler.ReadBlobContentAsync(
                userId, 
                directory, 
                sessionDirectory, 
                responseFileName);
            //Console.WriteLine($"Raw response content: {responseContent}");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error reading response blob content: {ex.Message}");
            PanelOutput = string.Empty;
            return;
        }

        PanelOutput=responseContent;
        // Retrieve agent settings for the given project feature
        agentSettings = _agentConfigurationService.GetAgentSettings(CurrentFeatureName);
        if (agentSettings != null)
            {
                try
                {
                    // Parse the JSON response into a list of messages
                    ChatMessages = Newtonsoft.Json.JsonConvert.DeserializeObject<List<ChatMessageM>>(PanelOutput);

                    // Format the final CopyWriter content with more prominent styling
                    if (!string.IsNullOrEmpty(agentSettings.EditorRoleName)) {
                        PanelOutput = FormatProminentWriterContent(
                            ChatMessages.LastOrDefault(m => m.Author == agentSettings.EditorRoleName)?.Content ?? "No message from CopyWriter found."
                        );
                    } else {
                        PanelOutput = FormatProminentWriterContent(
                            ChatMessages.LastOrDefault(m => m.Author == agentSettings.WriterRoleName)?.Content ?? "No message from CopyWriter found."
                        );
                    }
                }
                catch (Newtonsoft.Json.JsonSerializationException ex)
                {
                    Console.WriteLine($"Error deserializing response JSON: {ex.Message}");
                    PanelOutput = "Failed to process the response. Please try again later.";
                }
            }
            //TestDelegate(); // Test the delegate on first render

        StateHasChanged();
    }

    // Define a class to match the JSON structure
    public class RequestData
    {
        public string FeatureNameWorkflowName { get; set; }
        public string FeatureNameProject { get; set; }

        public string PanelInput { get; set; }
        public string Input { get; set; }
        public string Tags { get; set; }
        public string MasterTextSetting { get; set; }
        public string ResponseLength { get; set; }
        public string CreativeAdjustments { get; set; }
        public string AudienceLevel { get; set; }
        public string WritingStyle { get; set; }
        public string RelationSettings { get; set; }
        public string ResponseStyle { get; set; }
    }



    private void HandleOnSelectedSelectSession(FluentTreeItem selectedItem)
    {
        //SelectedItem = selectedItem;
        Console.WriteLine($"Selected selectedItem.Id: {selectedItem.Id}");
        Console.WriteLine($"Selected selectedItem.Text: {selectedItem.Text}");
    }

    // Method to get background color based on author
    private string GetBackgroundColor(string author)
    {
        return author switch
        {
            "CopyWriter" => "#f0f4fc",   // Light blue for CopyWriter
            "MarketingDirector" => "#fff5f5",  // Light red/pink for Marketing
            _ => "#f9f9f9",              // Default background color
        };
    }
    private string FormatProminentWriterContent(string content)
    {
        // Replace the Markdown-style bold syntax with HTML bold tags
        return content = content.Replace("**- Final Message:**", "<strong>- Final Message:</strong>");
/*
        return $@"
        <div style='
            font-size:12px;
            line-height:1.7;
            color:#2c3e50;
            background-color:#eef6fc;
            padding:20px;
            border-left:5px solid #4A90E2;
            border-radius:8px;
            margin-top:20px;
            '>
            <span style='font-size:18px; color:#1a73e8; font-weight:bold;'>Final Copy:</span>
            <br><br>
            <div style='font-size:16px; line-height:1.8; color:#333;'>
                {content}
            </div>
            <br><br>
            <em style='color:#95a5a6;'>End of Message</em>
        </div>";
        */
    }

    // Convert Markdown to HTML
    private string ConvertMarkdownToHtml(string markdown)
    {
        var html = Markdown.ToHtml(markdown);

        // Customize styles for markdown elements
        html = html.Replace("<strong>", "<strong style='font-weight:bold; color:#1a73e8;'>");
        html = html.Replace("<p>", "<p style='margin-bottom:1em;'>");
        html = html.Replace("<em>", "<em style='color:#95a5a6;'>");

        // Additional styling for blockquotes, code blocks, etc.
        // Example:
        html = html.Replace("<blockquote>", "<blockquote style='margin-left:20px; color:#555;'>");

        return html;
    }

    private async Task StartNewSession()
    {
        // Clear the necessary fields
        PanelInput = string.Empty;
        UserInput = string.Empty;
        PanelOutput = string.Empty;

        // Reset AI Copilot Settings
        //AICopilotSettings.ResponseLengthVal = string.Empty;
        //AICopilotSettings.CreativeAdjustmentsVal = string.Empty;
        //AICopilotSettings.AudienceLevelVal = string.Empty;
        //AICopilotSettings.WritingStyleVal = string.Empty;
        //AICopilotSettings.RelationSettingsVal = string.Empty;
        //AICopilotSettings.ResponseStyleVal = string.Empty;

        // Clear the selected item
        SelectedItem = null;

        // Set the new session flag
        isNewSession = true;


        // Optionally, you might want to deselect any selected item in the TreeView
        // This depends on how your TreeView component is implemented
        // You might need to add a method to your TreeView to deselect items

        //await LoadSessionsAsync();
        sessionSelectedName = null;
    }
    HorizontalAlignment Horizontal;
    VerticalAlignment Vertical;

}


@code {
    //private string? displayName;
    //private string userEmail = "konstantine@aitrailblazer.com";
    //private string userFullName;
    private string userPhoneNumer;
    private string userLanguage;
    private string userAddress;
    private string userPrincipalJson = "default-principal";
    private string pluginPath;
     private IEnumerable<string> pluginFiles = Enumerable.Empty<string>();

    private bool isInitialized = false;
    private string? Tags;

    private ITreeViewItem? SelectedItem;
    private IEnumerable<ITreeViewItem>? ItemsSessions = new List<ITreeViewItem>();
    private List<Session> Sessions = new();
    private Session? CurrentSession { get; set; }
    private AgentSettings agentSettings;

       protected override async Task OnInitializedAsync()
    {
        if (!isInitialized)
        {
            await LoadUserDataAsync();
            isInitialized = true;
        }
    }
    private async Task LoadUserDataAsync()
    {
        pluginPath = PluginService.GetPluginsPath();
        Console.WriteLine($"ChatPaneSplitter Plugin Path: {pluginPath}");

        Console.WriteLine($"ChatPaneSplitter OnInitializedAsync CurrentFeatureName: {CurrentFeatureName}");

        PlaceholderCommandText = $"ChatPaneSplitter Prompt/Command Line: Enter your prompt here. If you need to use lengthy texts or code, please enter or paste them in the Context field located above on the left.";

    }
}


@code{


    public void TriggerParseOntologyTree(string markdownText)
    {
        OntologyTree = ParseOntologyTreeMarkdown(markdownText);
        StateHasChanged(); // Refresh the UI
    }
}


@code {
    private List<Chapter> OntologyTree = new List<Chapter>();
    private List<OntologyTreeViewItem> treeViewItems = new List<OntologyTreeViewItem>();
    private string currentSelectedTreeViewItemOntology;
    private FluentTreeItem? currentSelectedTreeItemOntology;

    private string selectedSectionContent = string.Empty;
    private string selectedSectionContentFinal = string.Empty;
    //private string activeId = "0"; // Default active accordion ID
    private string currentSelectedOntologyTitle  = string.Empty; 
    protected override void OnInitialized()
    {
        // Load and parse the markdown document
        //var markdownText = System.IO.File.ReadAllText("GitHub_SoftwareDocumentation.md");
        OntologyTree = ParseOntologyTreeMarkdown(_selectedFileContent);
        treeViewItems = OntologyTree.Select(c => new OntologyTreeViewItem(c)).ToList();
    }

 /// <summary>
/// Parses the ontology tree from markdown text, handling bold and italic markers.
/// </summary>
private List<Chapter> ParseOntologyTreeMarkdown(string markdownText)
{
    var chapters = new List<Chapter>();
    var lines = markdownText.Split('\n');

    Chapter? currentChapter = null;
    Section? currentSection = null;
    SubSection? currentSubSection = null;

    // Root-level title (for example, # Pitch Deck)
    string? rootTitle = null;

    foreach (var line in lines)
    {
        var trimmedLine = line.Trim();

        // Handle root title (single #), which is treated as the full document header
        if (trimmedLine.StartsWith("# "))
        {
            // This is the root-level item, save the title (e.g., "Pitch Deck")
            rootTitle = trimmedLine.Substring(2).Trim(new[] { '*', ' ', '_' });
        }
        // Handle chapter titles (## level)
        else if (trimmedLine.StartsWith("## "))
        {
            var title = trimmedLine.Substring(3).Trim(new[] { '*', ' ', '_' });
            currentChapter = new Chapter
            {
                Title = title,
                Sections = new List<Section>()
            };
            chapters.Add(currentChapter);
            currentSection = null;
            currentSubSection = null;
        }
        // Handle section titles (### level)
        else if (trimmedLine.StartsWith("### "))
        {
            if (currentChapter == null)
            {
                // Handle sections without a parent chapter
                continue;
            }

            var sectionTitle = trimmedLine.Substring(3).Trim(new[] { '*', ' ', '_' });
            currentSection = new Section
            {
                Title = sectionTitle,
                SubSections = new List<SubSection>()
            };
            currentChapter.AddSection(currentSection);
            currentSubSection = null;
        }
        // Handle subsections (- list items)
        else if (trimmedLine.StartsWith("- "))
        {
            if (currentSection == null)
            {
                // Handle subsections without a parent section
                continue;
            }

            var subSectionParts = trimmedLine.Substring(2).Split(new[] { ':' }, 2);
            var subSectionTitle = subSectionParts[0].Trim(new[] { '*', ' ', '_' });
            var subSectionContent = subSectionParts.Length > 1 ? subSectionParts[1].Trim() : string.Empty;

            currentSubSection = new SubSection
            {
                Title = subSectionTitle,
                Content = subSectionContent
            };
            currentSection.AddSubSection(currentSubSection);
        }
        // Handle continuation of subsection content
        else if (currentSubSection != null && !string.IsNullOrWhiteSpace(trimmedLine))
        {
            currentSubSection.Content += " " + trimmedLine;
        }
    }

    // If a root title was found, store it somewhere (e.g., as a separate root item in the tree or metadata)
    if (!string.IsNullOrEmpty(rootTitle))
    {
        Console.WriteLine($"Root title detected: {rootTitle}");
        // Optionally, you could add this as a special Chapter or RootItem in your data model
    }

    return chapters;
}
    private void HandleOnSelectedChangeOntology(FluentTreeItem selectedTreeItem)
    {
        if (Guid.TryParse(selectedTreeItem.Id, out Guid selectedId))
        {
            // Log the selected TreeItem ID for debugging
            Console.WriteLine($"HandleOnSelectedChangeOntology selectedTreeItem.Id: {selectedId}");
            Console.WriteLine($"HandleOnSelectedChangeOntology selectedTreeItem.Text: {selectedTreeItem.Text}");
            // 1. Introduction
            currentSelectedOntologyTitle = selectedTreeItem.Text;
            // Find and display content based on the selected TreeItem's Guid ID
            FindAndDisplayOntologyContent(selectedId);
        }
        else
        {
            Console.WriteLine($"Failed to parse selectedTreeItem.Id: {selectedTreeItem.Id}");
        }
    }

    private void FindAndDisplayOntologyContent(Guid selectedId)
    {
        // Find the corresponding tree item based on the Guid ID
        var selectedItem = OntologyTree
            .SelectMany(chapter => new[] { chapter as ITreeItem }
                .Concat(chapter.Sections)
                .Concat(chapter.Sections.SelectMany(section => section.SubSections)))
            .FirstOrDefault(item => item.Id == selectedId); // Match by Guid

        if (selectedItem != null)
        {
            switch (selectedItem)
            {
                case Chapter chapter:
                    if (IsRootChapter(chapter)) // Check if it's the root
                    {
                        selectedSectionContentFinal = GenerateFullOntologyContent(); // Copy the full document
                    }
                    else
                    {
                        selectedSectionContentFinal = GenerateChapterContent(chapter); // Handle chapter
                    }
                    break;

                case Section section:
                    var parentChapter = OntologyTree.FirstOrDefault(ch => ch.Sections.Contains(section)); // Find parent chapter
                    if (parentChapter != null)
                    {
                        selectedSectionContentFinal = GenerateSectionContent(section, parentChapter); // Pass section and parent chapter
                    }
                    break;

                case SubSection subSection:
                    var parentSection = OntologyTree.SelectMany(ch => ch.Sections)
                                                    .FirstOrDefault(sec => sec.SubSections.Contains(subSection)); // Find parent section
                    var parentChapterForSubSection = OntologyTree.FirstOrDefault(ch => ch.Sections.Contains(parentSection)); // Find parent chapter
                    if (parentSection != null && parentChapterForSubSection != null)
                    {
                        selectedSectionContentFinal = GenerateSubSectionContent(subSection, parentSection, parentChapterForSubSection); // Pass subSection, parentSection, and parentChapter
                    }
                    break;

                default:
                    selectedSectionContentFinal = "No content available.";
                    break;
            }

            Console.WriteLine($"Displaying content for selected ID: {selectedId}");
            Console.WriteLine($"Selected Section Content: {selectedSectionContentFinal}");
        }
        else
        {
            Console.WriteLine($"No matching item found for selected ID: {selectedId}");
        }
    }

    // Method to check if the selected item is the root chapter
    private bool IsRootChapter(Chapter chapter)
    {
        // Assuming the first chapter in the list is the root representing the full document
        return OntologyTree.FirstOrDefault() == chapter;
    }

    // Method to generate the content for the full ontology tree (entire document)
    private string GenerateFullOntologyContent()
    {
        var fullContentBuilder = new StringBuilder();

        // Iterate over each chapter and its sections/subsections
        foreach (var chapter in OntologyTree)
        {
            fullContentBuilder.AppendLine(GenerateChapterContent(chapter));
        }

        return fullContentBuilder.ToString();
    }

    /// <summary>
    /// Handles the selection change in the ontology tree.
    /// </summary>
 
     /// <summary>
    /// Handles the event when a tree view item is selected.
    /// </summary>    
    
    private async Task HandleOnSelectedChangeOntology1()
{
    Logger.LogInformation($"HandleOnSelectedChangeOntology called. Current selected ID: {currentSelectedTreeViewItemOntology}");

    if (string.IsNullOrEmpty(currentSelectedTreeViewItemOntology))
    {
        Logger.LogWarning("currentSelectedTreeViewItemOntology is null or empty. No selection made.");
        return;
    }

    if (OntologyTree == null || !OntologyTree.Any())
    {
        Logger.LogWarning("OntologyTree is null or empty.");
        return;
    }

    // Find the selected item in the tree
    var selectedTreeViewItem = OntologyTree
        .SelectMany(chapter => new[] { chapter as ITreeItem }.Concat(chapter.Sections)
            .Concat(chapter.Sections.SelectMany(section => section.SubSections)))
        .FirstOrDefault(item => item.Id.ToString() == currentSelectedTreeViewItemOntology);

    if (selectedTreeViewItem != null)
    {
        currentSelectedOntologyTitle = selectedTreeViewItem.Title;
        Logger.LogInformation($"Selected Item: {selectedTreeViewItem.Title}");
        selectedSectionContentFinal = string.Empty;

        // Handle the content based on heading level
        selectedSectionContentFinal = GetContentForHeadingFromTree(selectedTreeViewItem);
        
        Logger.LogInformation($"Selected Section Content: {selectedSectionContentFinal}");
    }
    else
    {
        Logger.LogWarning($"Selected item not found in OntologyTree. ID: {currentSelectedTreeViewItemOntology}");
    }
}
private string GetContentForHeadingFromTree(ITreeItem selectedTreeViewItem)
{
    // Traverse the OntologyTree to find the selected heading and extract content dynamically
    StringBuilder contentBuilder = new StringBuilder();

    // Traverse the chapters, sections, and subsections to build the content based on the selected item
    bool isWithinSelectedSection = false;

    foreach (var chapter in OntologyTree)
    {
        if (chapter == selectedTreeViewItem)
        {
            // Copy the entire chapter content if it's the selected heading (e.g., # Software Documentation Ontologies)
            contentBuilder.Append(GenerateChapterContent(chapter));
            return contentBuilder.ToString();
        }

        foreach (var section in chapter.Sections)
        {
            if (section == selectedTreeViewItem)
            {
                // Begin copying the content between this section and the next section of the same level
                isWithinSelectedSection = true;
                contentBuilder.Append(GenerateSectionContent(section, chapter));
            }
            else if (isWithinSelectedSection)
            {
                // Stop copying once the next section or chapter is encountered
                return contentBuilder.ToString();
            }

            foreach (var subSection in section.SubSections)
            {
                if (subSection == selectedTreeViewItem)
                {
                    // Begin copying content for the selected subsection
                    isWithinSelectedSection = true;
                    contentBuilder.Append(GenerateSubSectionContent(subSection, section, chapter));
                }
                else if (isWithinSelectedSection)
                {
                    // Stop copying at the next subsection or higher-level heading
                    return contentBuilder.ToString();
                }
            }
        }
    }

    return contentBuilder.ToString();
}
private string GenerateChapterContent(Chapter chapter)
{
    StringBuilder chapterContent = new StringBuilder();
    chapterContent.AppendLine($"# {chapter.Title}");

    foreach (var section in chapter.Sections)
    {
        chapterContent.AppendLine(GenerateSectionContent(section, chapter));
    }

    return chapterContent.ToString();
}
private string GenerateSectionContent(Section section, Chapter chapter)
{
    StringBuilder sectionContent = new StringBuilder();
    sectionContent.AppendLine($"## {section.Title}");

    foreach (var subSection in section.SubSections)
    {
        sectionContent.AppendLine(GenerateSubSectionContent(subSection, section, chapter));
    }

    return sectionContent.ToString();
}
private string GenerateSubSectionContent(SubSection subSection, Section section, Chapter chapter)
{
    StringBuilder subSectionContent = new StringBuilder();
    subSectionContent.AppendLine($"### {subSection.Title}");
    subSectionContent.AppendLine(subSection.Content); // Assuming subSection.Content has the actual text content.

    return subSectionContent.ToString();
}




    /// <summary>
    /// Generates the final content for a selected Chapter.
    /// </summary>
    private string GenerateChapterFinalContent(Chapter chapter)
    {
        var contentBuilder = new StringBuilder();
        contentBuilder.AppendLine($"# {chapter.Title}");
        foreach (var section in chapter.Sections)
        {
            contentBuilder.AppendLine($"## {section.Title}");
            foreach (var subSection in section.SubSections)
            {
                contentBuilder.AppendLine($"{subSection.ContentFinal}");
            }
        }
        return contentBuilder.ToString();
    }


    private void HandleOnAccordionItemChange(string newActiveId)
    {
        activeId = newActiveId;
    }
}

@code {
    string? activeid = "ConversationalMemory-id";
    string currenttab = "ConversationalMemory-id";
    private async Task HandleOnTabChange(FluentTab tab)
    {
        currenttab = tab.Id;
        Console.WriteLine($"ChatPaneSplitter HandleOnTabChange Tab changed to {tab.Id}");


    }

      // Declare OnUpdateFileContent as an EventCallback if it's passed from another component
    [Parameter] public EventCallback<string> OnUpdateFileContent { get; set; }

// This method handles loading file content and assigns it to PanelInput
    private void HandleFileContentLoaded(string fileContent)
    {
        PanelInput = fileContent; // Assign file content to PanelInput
        StateHasChanged(); // Update the UI
    }



    // This method handles loading issue content and assigns it to PanelInput
    private void HandleIssueContentLoaded(string issueContent)
    {
        PanelInput = issueContent; // Assign issue content to PanelInput
        StateHasChanged(); // Update the UI
    }
    public string GetPanelOutput()
    {
        //Console.WriteLine($"GetPanelOutput invoked, returning: {PanelOutput}");

        return PanelOutput;
    }

     private void TestDelegate()
    {
        var output = GetPanelOutput();
        Console.WriteLine($"TestDelegate: {output}");
    }


}

@code {
    string? activeid1 = "Work-id"; //  Reference-id
    FluentTab? changedto;

    private void HandleOnMainTabChange(FluentTab tab)
    {
        changedto = tab;
        Console.WriteLine($"HandleOnMainTabChange: Tab changed to: {tab.Id}");
        if (tab.Id == "Work-id")
        {
            //activeid = "Work-id";
        }
        else if (tab.Id == "Reference-id")
        {
            //Console.WriteLine($"HandleOnMainTabChange SelectedChangeOntology: {currentSelectedTreeItemOntology.Id}");

            //SelectedChangeOntology(currentSelectedTreeItemOntology);
        }
    }
        private async Task PanelOutputFinalReport(string contentToCopy)
    {
        loadingOutput6 = true;
        StateHasChanged(); // Notify Blazor to re-render the UI with the loading state

        await Task.Delay(2000);

        loadingOutput6 = false;
        StateHasChanged(); // Notify Blazor to re-render the UI after loading is complete
    }
        private void HandlePanelOutputFinalSwitch(ChangeEventArgs e)
    {
        Console.WriteLine($"Switch value: {PanelOutputFinalSwitchValue}");

        if (PanelOutputFinalSwitchValue)
        {
            Console.WriteLine("Switch on - Edit mode");
        }
        else
        {
            Console.WriteLine("Switch off - View mode");
        }
        ProcessPanelOutputFinal();
    }
        private void ProcessPanelOutputFinal()
    {
        string inputString1 = FormattingUtility.RemoveParametersTags(PanelOutputFinal);
        if (masterTextSetting == "Image")
        {
            ProcessedPanelOutputFinal = PanelOutputFinal;
            Console.WriteLine($"Processed ProcessedPanelOutputFinal: {ProcessedPanelOutputFinal}");
        } else if ((FeatureNamePipeline == "AIDiagramCodex") || (FeatureNameProject == "AIDiagramCodex")) {
            string remainderString = FormattingUtility.ExtractRemainderString(inputString1, "##########");
            ProcessedPanelOutputFinal = remainderString;
 
            Console.WriteLine($"Processed PanelOutput: {ProcessedPanelOutputFinal}");
        } else {
                ProcessedPanelOutputFinalHTML= (MarkupString)FormattingUtility.RenderMarkdownToHtml(PanelOutputFinal);
                                
                Console.WriteLine($"ProcessedPanelOutputFinalHTML: {ProcessedPanelOutputFinalHTML}");

         }
    }
    [Parameter]
    public EventCallback OnClearReference { get; set; }

    private void ClearReference()
    {
        // Clear local properties
        SelectedFile = null;
        SelectedFileContent = string.Empty;

        selectedSectionContent = string.Empty;
        selectedSectionContentFinal = string.Empty;

        currentSelectedTreeItemOntology = null;
        currentSelectedOntologyTitle = null;


        // Notify the parent that the references should be cleared as well
        if (OnClearReference.HasDelegate)
        {
            OnClearReference.InvokeAsync();
        }

        StateHasChanged(); // Refresh the component if necessary
    }
    private void ClearReferenceSelection()
    {
        selectedSectionContentFinal = string.Empty;
        currentSelectedOntologyTitle = string.Empty;   
        currentSelectedTreeItemOntology = null;
    }
}

@code {

    private bool loadingOutput1 = false;
    private bool loadingOutput2 = false;
    private bool loadingOutput3 = false;
    private bool loadingOutput4 = false;
    private bool loadingOutput5 = false;
    private bool loadingOutput6 = false;

    private void ClearPanelInput()
    {
        PanelInput = string.Empty;
    }

    private void ClearPanelOutput()
    {
        PanelOutput = string.Empty;
    }
 
    private async Task CopyToClipboard()
    {
        if (!string.IsNullOrEmpty(PanelOutput))

        loadingOutput1 = true;
        StateHasChanged(); // Notify Blazor to re-render the UI with the loading state

        await JSRuntime.InvokeVoidAsync("navigator.clipboard.writeText", PanelOutput);

        // Wait for 2000 milliseconds (2 seconds)
        await Task.Delay(2000);

        loadingOutput1 = false;
        StateHasChanged(); // Notify Blazor to re-render the UI after loading is complete
    }
    private async Task CopyOutputToInput()
    {
        if (!string.IsNullOrEmpty(PanelOutput))
            {
            loadingOutput2 = true;
            StateHasChanged(); // Notify Blazor to re-render the UI with the loading state

            PanelInput = PanelOutput;

            // Wait for 2000 milliseconds (2 seconds)
            await Task.Delay(2000);

            loadingOutput2 = false;
            StateHasChanged(); // Notify Blazor to re-render the UI after loading is complete
        }
    }
}


@code{

    string activeId = "accordion-1";

    FluentAccordionItem? changed;

    private void HandleOnAccordionItemChange(FluentAccordionItem item)
    {
        changed = item;
    }
        private void HandleOnSelectedChangeAICopilotSettings(FluentTreeItem selectedTreeItem)
    {

        currentSelectedTreeItemAICopilotSettings = selectedTreeItem;
        Console.WriteLine($"currentSelectedTreeItemAICopilotSettings: {currentSelectedTreeItemAICopilotSettings.Id}");

        var parts = currentSelectedTreeItemAICopilotSettings.Id.Split('_');
        if (parts.Length == 2)
        {
            HandleSelectedChangeAICopilotSettings(parts[0], parts[1]);
        }
        else
        {
            Console.WriteLine($"Invalid selected item ID format: {currentSelectedTreeItemAICopilotSettings.Id}");
        }
    }
    private void HandleSelectedChangeAICopilotSettings(string componentName, string value)
    {
        // Log the state before change
        Console.WriteLine($"Before Change: WritingStyle={AICopilotSettings.WritingStyleVal}, AudienceLevel={AICopilotSettings.AudienceLevelVal}, ResponseLength={AICopilotSettings.ResponseLengthVal}, CreativeAdjustments={AICopilotSettings.CreativeAdjustmentsVal}, RelationSettings={AICopilotSettings.RelationSettingsVal}, ResponseStyle={AICopilotSettings.ResponseStyleVal}");

        switch (componentName)
        {
            case "ResponseLength":
                AICopilotSettings.ResponseLengthVal = value;  // No toggle logic here
                break;
            case "CreativeAdjustments":
                AICopilotSettings.CreativeAdjustmentsVal = value;  // No toggle logic here
                break;
            case "WritingStyle":
                AICopilotSettings.WritingStyleVal = value;
                break;
            case "AudienceLevel":
                AICopilotSettings.AudienceLevelVal = value;
                break;
            case "RelationSettings":
                AICopilotSettings.RelationSettingsVal = value;
                break;
            case "ResponseStyle":
                AICopilotSettings.ResponseStyleVal = value;
                break;
            default:
                Console.WriteLine($"Unknown component name: {componentName}");
                break;
        }

        // Log the state after change
        Console.WriteLine($"After Change: WritingStyle={AICopilotSettings.WritingStyleVal}, AudienceLevel={AICopilotSettings.AudienceLevelVal}, ResponseLength={AICopilotSettings.ResponseLengthVal}, CreativeAdjustments={AICopilotSettings.CreativeAdjustmentsVal}, RelationSettings={AICopilotSettings.RelationSettingsVal}, ResponseStyle={AICopilotSettings.ResponseStyleVal}");

        string pipeDelimitedString = PipeDelimited();
        Console.WriteLine($"pipeDelimitedString {pipeDelimitedString}");
    }

    private string searchQuery = string.Empty;
    private List<ComponentModel> componentsAICopilotSettings = new List<ComponentModel>
    {
        new ComponentModel 
        { 
            Name = "Writing Style", 
            Id = "WritingStyle", 
            Icon = new Icons.Regular.Size20.Book(), 
            SubComponents = new List<ComponentModel>
            {
                new ComponentModel { Name = "Casual", Id = "WritingStyle_Casual", Icon = new Icons.Regular.Size24.People() },
                new ComponentModel { Name = "Formal", Id = "WritingStyle_Formal", Icon = new Icons.Regular.Size24.Briefcase() },
                new ComponentModel { Name = "Technical", Id = "WritingStyle_Technical", Icon = new Icons.Regular.Size24.Code() },
                new ComponentModel { Name = "Persuasive", Id = "WritingStyle_Persuasive", Icon = new Icons.Regular.Size24.Megaphone() },
                new ComponentModel { Name = "Narrative", Id = "WritingStyle_Narrative", Icon = new Icons.Regular.Size24.BookOpen() },
                new ComponentModel { Name = "Exhaustive", Id = "WritingStyle_Exhaustive", Icon = new Icons.Regular.Size24.ReadingList() },
                new ComponentModel { Name = "Comprehensive", Id = "WritingStyle_Comprehensive", Icon = new Icons.Regular.Size24.ClipboardTaskListLtr() },
                new ComponentModel { Name = "Detailed", Id = "WritingStyle_Detailed", Icon = new Icons.Regular.Size24.Search() },
                new ComponentModel { Name = "Concise", Id = "WritingStyle_Concise", Icon = new Icons.Regular.Size24.ContractDownLeft() },
                new ComponentModel { Name = "Laconic", Id = "WritingStyle_Laconic", Icon = new Icons.Regular.Size24.Cut() }
            }
        },
        new ComponentModel 
        { 
            Name = "Audience Level", 
            Id = "AudienceLevel", 
            Icon = new Icons.Regular.Size20.PeopleAudience(), 
            SubComponents = new List<ComponentModel>
            {
                new ComponentModel { Name = "Novice", Id = "AudienceLevel_Novice", Icon = new Icons.Regular.Size24.BookOpen() },
                new ComponentModel { Name = "Intermediate", Id = "AudienceLevel_Intermediate", Icon = new Icons.Regular.Size24.LightbulbPerson() },
                new ComponentModel { Name = "Advanced", Id = "AudienceLevel_Advanced", Icon = new Icons.Regular.Size24.BrainCircuit() },
                new ComponentModel { Name = "Superior", Id = "AudienceLevel_Superior", Icon = new Icons.Regular.Size24.Trophy() },
                new ComponentModel { Name = "Distinguished", Id = "AudienceLevel_Distinguished", Icon = new Icons.Regular.Size24.Ribbon() }
            }
        },
        new ComponentModel 
        { 
            Name = "Response Length (Tokens)", 
            Id = "ResponseLength", 
            Icon = new Icons.Regular.Size20.DocumentFit(),
            SubComponents = new List<ComponentModel>
            {
                new ComponentModel { Name = "16", Id = "ResponseLength_16", Icon = new Icons.Regular.Size24.DocumentFit() },
                new ComponentModel { Name = "32", Id = "ResponseLength_32", Icon = new Icons.Regular.Size24.DocumentFit() },
                new ComponentModel { Name = "64", Id = "ResponseLength_64", Icon = new Icons.Regular.Size24.DocumentFit() },
                new ComponentModel { Name = "128", Id = "ResponseLength_128", Icon = new Icons.Regular.Size24.DocumentFit() },
                new ComponentModel { Name = "256", Id = "ResponseLength_256", Icon = new Icons.Regular.Size24.DocumentFit() },
                new ComponentModel { Name = "512", Id = "ResponseLength_512", Icon = new Icons.Regular.Size24.DocumentFit() },
                new ComponentModel { Name = "1024", Id = "ResponseLength_1024", Icon = new Icons.Regular.Size24.DocumentFit() },
                new ComponentModel { Name = "2048", Id = "ResponseLength_2048", Icon = new Icons.Regular.Size24.DocumentFit() },
                new ComponentModel { Name = "4096", Id = "ResponseLength_4096", Icon = new Icons.Regular.Size24.DocumentFit() },
                new ComponentModel { Name = "8192", Id = "ResponseLength_8192", Icon = new Icons.Regular.Size24.DocumentFit() },
                new ComponentModel { Name = "16384", Id = "ResponseLength_16384", Icon = new Icons.Regular.Size24.DocumentFit() }            }
                        },
        new ComponentModel 
        { 
            Name = "Creative Adjustments", 
            Id = "CreativeAdjustments", 
            Icon = new Icons.Regular.Size16.Target(),
            SubComponents = new List<ComponentModel>
            {
                new ComponentModel { Name = "Focused", Id = "CreativeAdjustments_Focused", Icon = new Icons.Regular.Size16.Target() },
                new ComponentModel { Name = "Analytical", Id = "CreativeAdjustments_Analytical", Icon = new Icons.Regular.Size24.Lightbulb() },
                new ComponentModel { Name = "Balanced", Id = "CreativeAdjustments_Balanced", Icon = new Icons.Regular.Size24.Scales() },
                new ComponentModel { Name = "Adaptable", Id = "CreativeAdjustments_Adaptable", Icon = new Icons.Regular.Size24.ScaleFit() },
                new ComponentModel { Name = "Open", Id = "CreativeAdjustments_Open", Icon = new Icons.Regular.Size24.Globe() },
                new ComponentModel { Name = "Inspired", Id = "CreativeAdjustments_Inspired", Icon = new Icons.Regular.Size24.BrainCircuit() },
                new ComponentModel { Name = "Creative", Id = "CreativeAdjustments_Creative", Icon = new Icons.Regular.Size24.PaintBrush() },
                new ComponentModel { Name = "Innovative", Id = "CreativeAdjustments_Innovative", Icon = new Icons.Regular.Size24.Rocket() },
                new ComponentModel { Name = "Visionary", Id = "CreativeAdjustments_Visionary", Icon = new Icons.Regular.Size24.EyeTracking() }
            }
        },
        new ComponentModel 
        {
            Name = "Relation Settings", 
            Id = "RelationSettings", 
            Icon = new Icons.Regular.Size20.LightbulbCircle(),
            SubComponents = new List<ComponentModel>
            {
                new ComponentModel { Name = "Peer-to-Peer", Id = "RelationSettings_PeerToPeer", Icon = new Icons.Regular.Size24.People() },
                new ComponentModel { Name = "Upward", Id = "RelationSettings_Upward", Icon = new Icons.Regular.Size24.ArrowUp() },
                new ComponentModel { Name = "Downward", Id = "RelationSettings_Downward", Icon = new Icons.Filled.Size24.ArrowDown() },
                new ComponentModel { Name = "Customer", Id = "RelationSettings_Customer", Icon = new Icons.Regular.Size24.ContactCard() },
                new ComponentModel { Name = "Partner", Id = "RelationSettings_Partner", Icon = new Icons.Regular.Size24.Handshake() },
                new ComponentModel { Name = "Investor", Id = "RelationSettings_Investor", Icon = new Icons.Regular.Size24.Money() },
                new ComponentModel { Name = "Public Relations", Id = "RelationSettings_PublicRelations", Icon = new Icons.Regular.Size24.Globe() },
                new ComponentModel { Name = "Crisis", Id = "RelationSettings_Crisis", Icon = new Icons.Regular.Size24.Warning() },
                new ComponentModel { Name = "Instructional", Id = "RelationSettings_Instructional", Icon = new Icons.Regular.Size24.BookOpen() },
                new ComponentModel { Name = "Motivational", Id = "RelationSettings_Motivational", Icon = new Icons.Regular.Size24.Star() },
                new ComponentModel { Name = "Innovative", Id = "RelationSettings_Innovative", Icon = new Icons.Regular.Size24.Lightbulb() }
            }
        },
        new ComponentModel 
        {
            Name = "Response Style", 
            Id = "ResponseStyle", 
            Icon = new Icons.Regular.Size20.Edit(),
            SubComponents = new List<ComponentModel>
            {
                new ComponentModel { Name = "Summary", Id = "ResponseStyle_Summary", Icon = new Icons.Regular.Size24.BookInformation() },
                new ComponentModel { Name = "Alternatives", Id = "ResponseStyle_Alternatives", Icon = new Icons.Regular.Size24.ArrowSwap() },
                new ComponentModel { Name = "Elaborate", Id = "ResponseStyle_Elaborate", Icon = new Icons.Regular.Size24.TextParagraph() },
                new ComponentModel { Name = "Compare", Id = "ResponseStyle_Compare", Icon = new Icons.Regular.Size24.Scales() },
                new ComponentModel { Name = "Clarify", Id = "ResponseStyle_Clarify", Icon = new Icons.Regular.Size24.Search() },
                new ComponentModel { Name = "Predict", Id = "ResponseStyle_Predict", Icon = new Icons.Regular.Size24.WeatherSunny() },
                new ComponentModel { Name = "Synthesize", Id = "ResponseStyle_Synthesize", Icon = new Icons.Regular.Size24.BranchFork() },
                new ComponentModel { Name = "Question", Id = "ResponseStyle_Question", Icon = new Icons.Regular.Size24.QuestionCircle() },
                new ComponentModel { Name = "Reflect", Id = "ResponseStyle_Reflect", Icon = new Icons.Regular.Size24.Thinking() },
                new ComponentModel { Name = "Strict", Id = "ResponseStyle_Strict", Icon = new Icons.Regular.Size24.CheckmarkSquare() },
                new ComponentModel { Name = "Innovate", Id = "ResponseStyle_Innovate", Icon = new Icons.Regular.Size24.LightbulbCircle() }
            }
        }
    };

}


@code {
    private List<ComponentModel> componentsAICopilots = new List<ComponentModel>
    {
        new ComponentModel
        {
            WorkflowName = "Writing",
            Name = "Writing",
            Icon = new Icons.Regular.Size20.DocumentOnePageSparkle(),
            SubComponents = new List<ComponentModel>
            {
                new ComponentModel { Name = AICopilotDescriptionService.GetFriendlyNameForAICopilotService("AIWritingAssistant"), WorkflowName = "Writing", Id = "AIWritingAssistant", Icon = new Icons.Regular.Size20.Pen() },
                new ComponentModel { Name = AICopilotDescriptionService.GetFriendlyNameForAICopilotService("AIKeyPointsWizard"), WorkflowName = "Writing", Id = "AIKeyPointsWizard", Icon = new Icons.Regular.Size20.AppsList() },
                new ComponentModel { Name = AICopilotDescriptionService.GetFriendlyNameForAICopilotService("AIClearNote"), WorkflowName = "Writing", Id = "AIClearNote", Icon = new Icons.Regular.Size20.BookStar() },
                new ComponentModel { Name = AICopilotDescriptionService.GetFriendlyNameForAICopilotService("AIEmailWizard"), WorkflowName = "Writing", Id = "AIEmailWizard", Icon = new Icons.Regular.Size20.Mail() },
                new ComponentModel { Name = AICopilotDescriptionService.GetFriendlyNameForAICopilotService("AIInternalMemo"), WorkflowName = "Writing", Id = "AIInternalMemo", Icon = new Icons.Regular.Size20.StarEmphasis() },
                new ComponentModel { Name = AICopilotDescriptionService.GetFriendlyNameForAICopilotService("AIMessageOptimizer"), WorkflowName = "Writing",  Id = "AIMessageOptimizer", Icon = new Icons.Regular.Size20.EmojiEdit() },
                new ComponentModel { Name = AICopilotDescriptionService.GetFriendlyNameForAICopilotService("AINamesGen"), WorkflowName = "Writing", Id = "AINamesGen", Icon = new Icons.Regular.Size20.TextCaseTitle()},  
                new ComponentModel { Name = AICopilotDescriptionService.GetFriendlyNameForAICopilotService("AiTaskWizard"), WorkflowName = "Writing", Id = "AiTaskWizard", Icon = new Icons.Regular.Size20.TextCaseTitle()}
            }
        },
        new ComponentModel
        {
            WorkflowName = "CodeAndDocumentation",
            Name = "Code & Documentation",
            Icon = new Icons.Regular.Size20.GlanceHorizontalSparkles(),
            SubComponents = new List<ComponentModel>
            {
                new ComponentModel { Name = AICopilotDescriptionService.GetFriendlyNameForAICopilotService("AIOntologyGen"), WorkflowName = "CodeAndDocumentation",Id = "AIOntologyGen", Icon = new Icons.Regular.Size20.DocumentBulletListMultiple() },
                new ComponentModel { Name = AICopilotDescriptionService.GetFriendlyNameForAICopilotService("AIReportGen"), WorkflowName = "CodeAndDocumentation", Id = "AIReportGen", Icon = new Icons.Regular.Size20.DocumentBulletListMultiple() },
                new ComponentModel { Name = AICopilotDescriptionService.GetFriendlyNameForAICopilotService("AISoftwareDocGen"), WorkflowName = "CodeAndDocumentation", Id = "AISoftwareDocGen", Icon = new Icons.Regular.Size20.DocumentBulletListMultiple() },
                new ComponentModel { Name = AICopilotDescriptionService.GetFriendlyNameForAICopilotService("AISoftwareCodeGen"), WorkflowName = "CodeAndDocumentation", Id = "AISoftwareCodeGen", Icon = new Icons.Regular.Size20.DocumentBulletListMultiple() },
                new ComponentModel { Name = AICopilotDescriptionService.GetFriendlyNameForAICopilotService("COSE"), WorkflowName = "CodeAndDocumentation", Id = "COSE", Icon = new Icons.Regular.Size20.BrainCircuit() },
                //new ComponentModel { Name = AICopilotDescriptionService.GetFriendlyNameForAICopilotService("AIDiagramCodex"), Id = "AIDiagramCodex", Icon = new Icons.Regular.Size20.BrainCircuit() }
            }
        },
        new ComponentModel
        {
            WorkflowName = "StrategicInsights",
            Name = "Strategic Insights",
            Icon = new Icons.Regular.Size20.FlashSparkle(),
            SubComponents = new List<ComponentModel>
            {
                new ComponentModel { Name = AICopilotDescriptionService.GetFriendlyNameForAICopilotService("AIStrategiX"), WorkflowName = "StrategicInsights", Id = "AIStrategiX", Icon = new Icons.Regular.Size20.Chess() },
                new ComponentModel { Name = AICopilotDescriptionService.GetFriendlyNameForAICopilotService("AIInSightOut"), WorkflowName = "StrategicInsights",  Id = "AIInSightOut", Icon = new Icons.Regular.Size20.BuildingLighthouse() }
            }
        },
        new ComponentModel
        {
            WorkflowName = "Visuals",
            Name = "Visuals",
            Icon = new Icons.Regular.Size20.GlanceHorizontalSparkles(),
            SubComponents = new List<ComponentModel>
            {
                new ComponentModel { Name = AICopilotDescriptionService.GetFriendlyNameForAICopilotService("AILightRayArt"), WorkflowName = "Visuals",  Id = "AILightRayArt", Icon = new Icons.Regular.Size20.DesignIdeas() },
                new ComponentModel { Name = AICopilotDescriptionService.GetFriendlyNameForAICopilotService("AIVideoPromptGen"), WorkflowName = "Visuals", Id = "AIVideoPromptGen", Icon = new Icons.Regular.Size20.VideoChat() }                }
        },
    };

    private List<ComponentModel> filteredComponentsAICopilots = new List<ComponentModel>();
    public void FilterComponents(string FeatureNameProject)
    {
        if (FeatureNameProject == "AIContent")
        {
            CurrentFeatureName="AIWritingAssistant";
            filteredComponentsAICopilots = componentsAICopilots
                .Where(component => component.Name == "Writing" || 
                component.Name == "Code & Documentation" ||
                component.Name == "Strategic Insights"
                )
                .ToList();
        } 
    }
    private async Task  HandleOnSelectedChangeAICopilots(FluentTreeItem selectedTreeItem)
    {
        // Check if the selected tree item text is one of the values to skip
        var skipTexts = new[] { "Writing", "Code & Documentation", "Strategic Insights", "Visuals" };
        if (skipTexts.Contains(selectedTreeItem.Text))
        {
            // If the text is in the skip list, exit the method without assigning or processing further
            return;
        }

        currentSelectedTreeItemAICopilots = selectedTreeItem;
        Console.WriteLine($"currentSelectedTreeItemAICopilots Text: {currentSelectedTreeItemAICopilots.Text}");

        Console.WriteLine($"currentSelectedTreeItemAICopilots Id: {currentSelectedTreeItemAICopilots.Id}");
        CurrentFeatureName=currentSelectedTreeItemAICopilots.Id;
        Console.WriteLine($"HandleOnSelectedChangeAICopilots CurrentFeatureName: {CurrentFeatureName}");
        await OnFeatureNameChanged.InvokeAsync(CurrentFeatureName);
        // StartNewSession();
        //PlaceholderCommandText = $"Ask {CurrentFeatureName} or type / for commands. For example, /help";
        // Retrieve agent settings for the given project feature
        agentSettings = _agentConfigurationService.GetAgentSettings(CurrentFeatureName);
 
        HandleSelectedChangeAICopilots(currentSelectedTreeItemAICopilots.Id);

        // Append selected tree item text if it is not already present
        //if (!UserInput.Contains(currentSelectedTreeItemAICopilots.Id))
        //{
        //    UserInput += 
        //    AICopilotDescriptionService.GetFriendlyNameForAICopilotService(currentSelectedTreeItemAICopilots.Id) + " | ";
        //}

        // Split, trim, and remove duplicates
        var pipelines = UserInput.Split(new[] { " | " }, StringSplitOptions.RemoveEmptyEntries)
                                .Select(p => p.Trim())
                                .Distinct();
                                 // Clear existing sessions before reloading
        //await LoadSessionsAsync();

        // Rejoin the items to update UserInput string properly
        //UserInput = string.Join(" | ", pipelines) + " | ";
        // Update wizard steps
        //LoadWizardSteps(UserInput);
    }
    private void HandleSelectedChangeAICopilots(string componentId)
    {
        // Find the component by ID
        // AIWritingAssistant -> "Writing Assistant"
        ComponentModel selectedComponent = FindComponentById(componentsAICopilots, componentId);

        // Check if the component was found
        if (selectedComponent != null)
        {
            string featureFriendlyNameCurrent=selectedComponent.Name;
            CurrentFeatureWorkflowName=selectedComponent.WorkflowName;
            // Retrieve the raw data from the KnowledgeDocument
            //if (CurrentFeatureWorkflowName == "CodeAndDocumentation"){
            //    RawDataOntologies = KnowledgeDocument.GoProjectStructureOntologies;
            //    Console.WriteLine($"OnParametersSetAsync: RawDataOntologies: {RawDataOntologies}");
            //    OntologyTree = ParseOntologyTreeMarkdown(RawDataOntologies);
            //}

            // OntologyTree = ParseOntologyTreeMarkdown(SelectedFileContent);
            UpdateFeatureInfo(featureFriendlyNameCurrent);
            // Retrieve agent settings for the given project feature
            agentSettings = _agentConfigurationService.GetAgentSettings(CurrentFeatureName);
        }
        else
        {
            // Log if the component was not found
            Console.WriteLine($"Component not found for ID: {componentId}");
        }
    }
    private List<WizardStep> WizardSteps = new List<WizardStep>();


    private void LoadWizardSteps(string dataSource)
    {
        WizardSteps.Clear(); // Clear existing steps
        StateHasChanged(); // Notify the UI to update
        dataSource = dataSource.Replace("Pipeline: ", "");
        var stepsArray = dataSource.Split(new[] { " | " }, StringSplitOptions.RemoveEmptyEntries)
        .Distinct();
        //var stepsArray = dataSource.Split('|');

        foreach (var stepName in stepsArray)
        {
            Console.WriteLine($"LoadWizardSteps stepName {stepName}");           
            string SystemName = AICopilotDescriptionService.GetSystemNameForAICopilotService(stepName);
            string Description = AICopilotDescriptionService.GetLabelForAICopilotDescriptionService(SystemName);
            string featureFriendlyNameCurrent="";
            Console.WriteLine($"LoadWizardSteps: featureFriendlyNameCurrent: {featureFriendlyNameCurrent}");
            WizardSteps.Add(new WizardStep
            {
                Label = stepName.Trim(),
                //Summary = $"Summary for {featureFriendlyNameCurrent.Trim()}",
                Content = builder => { builder.AddContent(0, $"{Description}"); }
            });
        }
    }
    private ComponentModel FindComponentById(List<ComponentModel> components, string id)
    {
        foreach (var component in components)
        {
            if (component.Id == id)
                return component;

            var subComponent = FindComponentById(component.SubComponents, id);
            if (subComponent != null)
                return subComponent;
        }
        return null;
    }
    private void UpdateFeatureInfo(string friendlyName)
    {
        FeatureFriendlyNameCurrent = friendlyName ;
        Console.WriteLine($"FeatureFriendlyNameCurrent: {FeatureFriendlyNameCurrent}");

        FeatureNamePipeline = currentSelectedTreeItemAICopilots.Id;
        Console.WriteLine($"FeatureNamePipeline: {FeatureNamePipeline}");

    }
}
