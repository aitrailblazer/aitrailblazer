@rendermode InteractiveServer
@using Microsoft.AspNetCore.Hosting
@using Microsoft.Identity.Web
@using AITrailblazer.net.Services
@using AITrailblazer.net.Models
@using System.ComponentModel.DataAnnotations
@using Microsoft.AspNetCore.Authorization
@using Microsoft.Identity.Web
@using AITGraph.Sdk.Models
@using System.Text.Json
@using System.Text.Json.Serialization
@using Newtonsoft.Json
@using System.Text
@using Markdig
@using OntologyTreeApp.Models
@inject AITGraphService GraphService
@inject NavigationManager Navigation
@inject ILogger<User> Logger
@inject AITGraphService graphService


@inject PluginService PluginService

@inject AzureOpenAIHandler azureOpenAIHandler

@inject AICopilotSettingsService AICopilotSettings

@inject AgentConfigurationService _agentConfigurationService
@inject IJSRuntime JSRuntime
@implements IAsyncDisposable
                    <!--
                    <FluentTextBlock Typo="Typography.BodyStrong">
                        ID: <span class="value-text">@currentUserTenantID / @currentUserIdentityID</span>
                    </FluentTextBlock>


                <FluentStack Orientation="Orientation.Horizontal" HorizontalAlignment="@Horizontal" VerticalAlignment="@Vertical" VerticalGap="1">
                    <FluentTextBlock Typo="Typography.Body">
                        Email: <span class="value-text">@userEmail</span>
                    </FluentTextBlock>                    
                    <FluentTextBlock Typo="Typography.Body">
                        Time Zone: <span class="value-text">@userTimeZone</span>
                    </FluentTextBlock>
                    <FluentTextBlock Typo="Typography.Body">
                        Local Time: <span class="value-text">@userLocalTime</span>
                    </FluentTextBlock>
                    <FluentTextBlock Typo="Typography.Body">
                        Language: <span class="value-text">@userLanguage</span>
                    </FluentTextBlock>                
                </FluentStack>
                --> 
                <!--
                    <FluentTextBlock Typo="Typography.BodyStrong">
                        Phone: <span class="value-text">@GetUserPhoneNumber()</span>
                    </FluentTextBlock>
                    <FluentTextBlock Typo="Typography.BodyStrong">
                        Address: <span class="value-text">@GetUserAddress()</span>
                    </FluentTextBlock>
                -->

<FluentTabs @bind-ActiveTabId="@activeid1" OnTabChange="HandleOnMainTabChange" Class="top-tabs-font-size">
    <FluentTab Id="Work-id">
        <Header>
            Work
        </Header>
            <Content>
                <div @ref="containerDiv" class="splitter-container">
                    <FluentMultiSplitter>
                        <!-- LEFT Pane BEGIN -->
                        @if (showLEFTPane)  {
                            <FluentMultiSplitterPane Size="@LeftPaneSize" Min="0" Max="40%" Collapsible="false">
                                <div style="display: flex; height: 100%; position: relative;">
                                    @if (!isLeftPaneCollapsed) {
                                        <FluentCard MinimalStyle="true" Width="@FluentCardWidth"  Height="100%"  style="padding: 0px; max-height: 90vh; overflow-y: auto; background-color: #f7f7f7;">
                                        
                                            <FluentTabs @bind-ActiveTabId="@activeid" OnTabChange="HandleOnTabChange" Class="top-tabs-font-size">
                                                <FluentTab Id="ConversationalMemory-id" Icon="@(new Icons.Regular.Size24.ChatMultiple())">
                                                    <Header>
                                                        <FluentLabel Typo="Typography.Subject">Conversation Memory</FluentLabel>
                                                    </Header>
                                                    <Content>
                                                            <FluentCard MinimalStyle="true" Width="calc(100% - 1px)" Height="100%">
                                                                <FluentButton Id="NewThread" IconStart="@(new Icons.Regular.Size16.Add())" Title="New Thread" OnClick="@StartNewThread">New Thread</FluentButton>
                                                                @if (ItemsThreads != null && ItemsThreads.Any())
                                                                {
                                                                    <FluentTreeView Items="@ItemsThreads" @bind-SelectedItem="@currentSelectedTreeItemMessages" OnSelectedChange="@HandleSelectedThreadItemChanged" OnExpandedAsync="OnExpandedAsync" Class="session-tree-font-size">

                                                                    </FluentTreeView>
                                                                }
                                                                
                                                            </FluentCard>
                                                    </Content>
                                                </FluentTab>
                                                <!--
                                                <FluentTab Id="Github-id" >
                                                    <Header>
                                                        <i class="fab fa-github"></i> 
                                                            <span style="margin-left: 8px;">GitHub</span>
                                                    </Header>
                                                    <Content>
                                                        <ReposList GetPanelOutput="GetPanelOutput" 
                                                            OnFileContentLoaded="@HandleFileContentLoaded"
                                                            OnIssueContentLoaded="@HandleIssueContentLoaded" />
                                            
                                                    </Content>
                                                </FluentTab>
                                                -->
                                            </FluentTabs>
                                        </FluentCard>
                                    }
                                    <FluentButton IconEnd="@(isLeftPaneCollapsed ? new Icons.Regular.Size24.ChevronRight() : new Icons.Regular.Size24.ChevronLeft())"
                                    OnClick="@ToggleLeftPane"
                                    Style="position: absolute; right: 0; top: 50%; transform: translateY(-50%); height: 40px; width: 40px; z-index: 1;" />

                                </div>
                            </FluentMultiSplitterPane>
                        }
                        <!-- LEFT Pane END -->

                        <!-- MIDDLE Pane BEGIN -->
                        <FluentMultiSplitterPane  Size="@MiddlePaneSize" Min="30%" Collapsible="false">
                        <FluentLabel Typo="Typography.Subject">@CurrentFeatureWorkflowName | @CurrentFeatureName</FluentLabel>

                    <!--
                                @if (currentSelectedTreeItemOntology != null)
                                {
                                    <FluentLabel Typo="Typography.Subject">
                                        Reference: <b>@currentSelectedTreeItemOntology.Text</b>
                                    </FluentLabel>
                                }
                                
                    -->
                                @if (SelectedFile != null)
                                {
                                    <FluentStack Orientation="Orientation.Horizontal" HorizontalAlignment="@Horizontal"
                                        VerticalAlignment="@Vertical">
                                    <FluentLabel Typo="Typography.Subject">
                                        Reference: <b>@SelectedFile.FileName</b>
                                    </FluentLabel>
                                    @if (currentSelectedOntologyTitle != null)
                                    {
                                        <FluentLabel Typo="Typography.Subject">
                                            Chapter: <b>@currentSelectedOntologyTitle</b>
                                        </FluentLabel>
                                    }
                                    <FluentButton IconEnd="@(new Icons.Regular.Size20.Dismiss())" Title="Clear Reference"
                                                OnClick="ClearReference" /> 
                                    </FluentStack>
                                }

                            <FluentMultiSplitter Orientation="Orientation.Vertical" Style="border: 1px solid var(--middle-fill-rest);">
                                <div class="current-session">
                                    <FluentStack Orientation="Orientation.Vertical" HorizontalAlignment="@Horizontal"
                                        VerticalAlignment="@Vertical">

                                            @if (!string.IsNullOrEmpty(currentChatThreadId))
                                            {
                                                <FluentStack Orientation="Orientation.Horizontal" HorizontalAlignment="@Horizontal">
                                                    <FluentLabel Typo="Typography.Subject">Thread: @threadSelectedName</FluentLabel>
                                                    <FluentButton IconEnd="@(new Icons.Regular.Size16.Delete())" Title="Delete" OnClick="@(() => DeleteThread(currentChatThreadId))" Appearance="Appearance.Outline"/>
                                                </FluentStack>
                                            }

                                        </FluentStack>
                                </div>
                                <FluentMultiSplitterPane Size="60%" Min="20%" Max="80%" Collapsible="false">
                                    <FluentMultiSplitter Orientation="Orientation.Horizontal" >
                                    <!-- INPUT Pane BEGIN -->

                                        @if (showINPUTPane)
                                        {
                                        <FluentMultiSplitterPane Min="10%" Max="90%" Collapsible="false" Style="border: 2px;">
                                            <div style="padding:1px;min-width:800px">
                                                <FluentToolbar id="toolbar-fluent-components-input" style="width:100%">
                                                    @if (!string.IsNullOrEmpty(PanelInput))
                                                    {
                                                        <FluentSwitch @bind-Value="@(isHtmlView)" CheckedMessage="Formatted" UncheckedMessage="Plain text" />

                                                        <FluentButton IconEnd="@(new Icons.Regular.Size20.Dismiss())" Title="Clear Input"
                                                            OnClick="ClearPanelInput" /> 
                                                            <!--
                                                        <FluentCounterBadge Count="@inputTokenCount" BackgroundColor="@Color.Accent" Color="Color.Fill">
                                                            <ChildContent>
                                                                <FluentButton>
                                                                    <FluentIcon Value="@(new Icons.Regular.Size24.Info())" Color="@Color.Neutral" />
                                                                </FluentButton>
                                                            </ChildContent>
                                                            <BadgeTemplate>Tokens: @context</BadgeTemplate>
                                                        </FluentCounterBadge>
                                                        -->
                                                    }
                                                </FluentToolbar>
                                            </div>
                                                    <div style="max-height:100%; overflow-y:auto; padding: 1px; margin-bottom:40px;">
                                                        @if (isHtmlView)
                                                        {
                                                            <FluentLabel Typo="Typography.Body" Class="content-splitter-font-size" 
                                                                style="width: 100%; height: 400px; overflow-y: auto;">
                                                                @((MarkupString)ConvertMarkdownToHtml(PanelInput))
                                                            </FluentLabel>
                                                        }
                                                        else
                                                        {
                                                            <FluentTextArea Placeholder=@PlaceholderInputText
                                                                Typo="Typography.Body" @bind-Value="@PanelInput"
                                                                Class="content-splitter-font-size"
                                                                style="width: 100%;height: 100%;" Rows="@Rows" />
                                                        }
                                                    </div>
                                            </FluentMultiSplitterPane>
                                        }
                                        <!-- INPUT Pane END -->
                                        <!-- OUTPUT Pane BEGIN -->
                                        <FluentMultiSplitterPane Min="20%" Collapsible="false" Style="border: 1px solid;">
                                        <!-- Switch to Show/Hide FluentAccordion -->
                                        @if (!string.IsNullOrEmpty(PanelOutput))
                                        {
                                            <div style="padding:1px;min-width:800px">
                                                <FluentToolbar id="toolbar-fluent-components-input" style="width:100%">

                                                <FluentButton id="CopyOutputToInput" IconEnd="@(new Icons.Regular.Size20.ArrowCircleLeft())" Title="Transfer Content to Input"
                                                    Loading="@loadingOutput2"
                                                    OnClick="CopyOutputToInput" />
                                                <FluentButton id="CopyToClipboard" IconEnd="@(new Icons.Regular.Size20.Copy())" Title="Copy to clipboard"
                                                    Loading="@loadingOutput1"
                                                    OnClick="CopyToClipboard" />
                                                <FluentButton id="ClearPanelOutput" IconEnd="@(new Icons.Regular.Size20.Dismiss())" Title="Clear Output"
                                                    OnClick="ClearPanelOutput" />                    

                                                @if (threadSelectedItemName != null)
                                                {
                                                    <FluentButton id="DeleteThreadItem" IconEnd="@(new Icons.Regular.Size16.Delete())" Title="Delete" OnClick="@(() => DeleteThreadItem(currentChatThreadItemMessageId))" />
                                      
                                                    <FluentBadge Appearance="Appearance.Accent">
                                                        @timeTaken
                                                    </FluentBadge>

                                                    <FluentCounterBadge 
                                                        Count="@totalTokenCount" 
                                                        BackgroundColor="@(cacheHit ? Color.Neutral : Color.Accent)" 
                                                        Color="Color.Fill">
                                                        <ChildContent>
                                                            <FluentButton id="FluentCounterBadge">
                                                                <FluentIcon 
                                                                    Value="@(cacheHit ? (Icon)new Icons.Regular.Size24.Bookmark() : (Icon)new Icons.Regular.Size24.ChatSparkle())" 
                                                                    Color="@Color.Neutral" />
                                                            </FluentButton>
                                                        </ChildContent>
                                                        <BadgeTemplate>Tokens: @context</BadgeTemplate>
                                                    </FluentCounterBadge>
                                                    <FluentTooltip 
                                                        Anchor="FluentCounterBadge" 
                                                        HideTooltipOnCursorLeave="true" 
                                                        MaxWidth="200px" 
                                                        Delay="300">
                                                        <p>Response retrieved from the database for free if no tokens were used; otherwise, tokens were spent for processing.</p>
                                                    </FluentTooltip>


                                                }
                                                </FluentToolbar>
                                            </div>
                                        }
                                            <FluentLabel Typo="Typography.Subject">
                                            </FluentLabel>
                                            @if (agentSettings != null)
                                            {
                                            <!-- List of Authors with Tooltips -->
                                            <div style="margin-bottom: 10px;">
                                                <strong>AI Agents:</strong>
                                                <ul style="list-style-type:none; padding: 0;">
                                                    @if (!string.IsNullOrEmpty(agentSettings.WriterRoleName))
                                                    {
                                                        <li>
                                                            <span id="author-Writer">
                                                                <FluentIcon Value="@(new Icons.Regular.Size20.PenSparkle())" Color="@Color.Accent" Slot="start" />
                                                                <span style="color:#1a73e8; font-size:17px;">
                                                                    @agentSettings.WriterRoleName
                                                                </span>
                                                            </span>
                                                            @if (!string.IsNullOrEmpty(agentSettings.WriterRoleDescription))
                                                            {
                                                                <FluentTooltip Anchor="author-Writer" HideTooltipOnCursorLeave="true" MaxWidth="200px" Delay="300">
                                                                    @agentSettings.WriterRoleDescription
                                                                </FluentTooltip>
                                                            }
                                                        </li>
                                                    }

                                                    @if (!string.IsNullOrEmpty(agentSettings.EditorRoleName))
                                                    {
                                                        <li>
                                                            <span id="author-Editor">
                                                                <FluentIcon Value="@(new Icons.Regular.Size20.Edit())" Color="@Color.Warning" Slot="start" />
                                                                <span style="color:#f39c12; font-size:17px;">
                                                                    @agentSettings.EditorRoleName
                                                                </span>
                                                            </span>
                                                            @if (!string.IsNullOrEmpty(agentSettings.EditorRoleDescription))
                                                            {
                                                                <FluentTooltip Anchor="author-Editor" HideTooltipOnCursorLeave="true" MaxWidth="200px" Delay="300">
                                                                    @agentSettings.EditorRoleDescription
                                                                </FluentTooltip>
                                                            }
                                                        </li>
                                                    }

                                                    @if (!string.IsNullOrEmpty(agentSettings.ReviewerRoleName))
                                                    {
                                                        <li>
                                                            <span id="author-Reviewer">
                                                                <FluentIcon Value="@(new Icons.Regular.Size20.DocumentOnePageSparkle())" Color="@Color.Neutral" Slot="start" />
                                                                <span style="color:#e74c3c; font-size:18px; font-weight:bold;">
                                                                    @agentSettings.ReviewerRoleName
                                                                </span>
                                                            </span>
                                                            @if (!string.IsNullOrEmpty(agentSettings.ReviewerRoleDescription))
                                                            {
                                                                <FluentTooltip Anchor="author-Reviewer" HideTooltipOnCursorLeave="true" MaxWidth="200px" Delay="300">
                                                                    @agentSettings.ReviewerRoleDescription
                                                                </FluentTooltip>
                                                            }
                                                        </li>
                                                    }
                                                </ul>
                                            </div>

                                            <!-- Switch to Show/Hide FluentAccordion -->
                                            <FluentSwitch @bind-Value="isShowFullAgentsChatThreadVisible">Show Full Agents' Chat Thread</FluentSwitch>
                                            }

                                            <FluentCard MinimalStyle="false" Width="100%" Height="100%" style="overflow-y: auto;">
                                            @if (isShowFullAgentsChatThreadVisible && ChatMessages != null && ChatMessages.Any())
                                            {    
                                                <div style="max-height:100%; overflow-y:auto; padding: 10px; margin-bottom:40px;">

                                                    <!-- Displaying the chat content -->
                                                    <FluentIcon Value="@(new Icons.Regular.Size20.Chat())" Color="@Color.Neutral" Slot="start" />
                                                    <FluentLabel>Complete history of the conversation:</FluentLabel>
                                                    <FluentAccordion ActiveId="@activeId" OnAccordionItemChange="HandleOnAccordionItemChange">

                                                        @foreach (var message in ChatMessages)
                                                        {
                                                            var currentAuthor = message.Author;

                                                            <FluentAccordionItem>
                                                                <div slot="start">
                                                                    @if (currentAuthor == agentSettings.WriterRoleName)
                                                                    {
                                                                        <FluentIcon Value="@(new Icons.Regular.Size20.PenSparkle())" Color="@Color.Accent" Slot="start" />
                                                                        <span id="@($"message-{currentAuthor}")" style="color:#1a73e8; font-size:17px;">
                                                                            @agentSettings.WriterRoleName
                                                                        </span>
                                                                        <FluentTooltip Anchor="@($"message-{currentAuthor}")" HideTooltipOnCursorLeave="true" MaxWidth="200px" Delay="300">
                                                                            @agentSettings.WriterRoleDescription
                                                                        </FluentTooltip>
                                                                    }
                                                                    else if (currentAuthor == agentSettings.EditorRoleName)
                                                                    {
                                                                        <FluentIcon Value="@(new Icons.Regular.Size20.Edit())" Color="@Color.Warning" Slot="start" />
                                                                        <span id="@($"message-{currentAuthor}")" style="color:#f39c12; font-size:17px;">
                                                                            @agentSettings.EditorRoleName
                                                                        </span>
                                                                        <FluentTooltip Anchor="@($"message-{currentAuthor}")" HideTooltipOnCursorLeave="true" MaxWidth="200px" Delay="300">
                                                                            @agentSettings.EditorRoleDescription
                                                                        </FluentTooltip>
                                                                    }
                                                                    else if (currentAuthor == agentSettings.ReviewerRoleName)
                                                                    {
                                                                        <FluentIcon Value="@(new Icons.Regular.Size20.DocumentOnePageSparkle())" Color="@Color.Neutral" Slot="start" />
                                                                        <span id="@($"message-{currentAuthor}")" style="color:#e74c3c; font-size:18px; font-weight:bold;">
                                                                            @agentSettings.ReviewerRoleName
                                                                        </span>
                                                                        <FluentTooltip Anchor="@($"message-{currentAuthor}")" HideTooltipOnCursorLeave="true" MaxWidth="200px" Delay="300">
                                                                            @agentSettings.ReviewerRoleDescription
                                                                        </FluentTooltip>
                                                                    }
                                                                    else
                                                                    {
                                                                        <FluentIcon Value="@(new Icons.Regular.Size20.Person())" Color="@Color.Neutral" Slot="start" />
                                                                        <span style="color:#2c3e50; font-size:17px;">
                                                                            @currentAuthor
                                                                        </span>
                                                                    }
                                                                </div>
                                                                <div style="padding:15px; background-color:@GetBackgroundColor(currentAuthor); border-radius:8px;">
                                                                    @((MarkupString)ConvertMarkdownToHtml(message.Content))
                                                                </div>
                                                            </FluentAccordionItem>
                                                        }
                                                    </FluentAccordion>
                                                </div>
                                            }
                                            else
                                            {
                                                <div style="max-height:100%; overflow-y:auto; padding: 10px; margin-bottom:40px;">
                                                    @((MarkupString)ConvertMarkdownToHtml(PanelOutput))
                                                </div>
                                            }
                                            </FluentCard>
                                        </FluentMultiSplitterPane>
                                        <!-- OUTPUT Pane END -->
                                    </FluentMultiSplitter>
                                </FluentMultiSplitterPane>
                                <!-- COMMAND Line Pane BEGIN  -->
                                <FluentMultiSplitterPane   Collapsible="false">
                                    <FluentToolbar Orientation="Orientation.Horizontal" >
                                        <FluentStack Orientation="Orientation.Horizontal" HorizontalAlignment="@Horizontal"
                                        VerticalAlignment="@Vertical">

                                            <DynamicMasterTextSettings 
                                                FeatureName=@CurrentFeatureName
                                                CurrentSetting=@masterTextSetting
                                                OnMasterTextSettingRadioChange="@HandleMasterTextSettingRadioChange" 
                                                OnMyKnowledgeBaseCheckedChange="@HandleMyKnowledgeBaseCheckedChange" 
                                                OnTagsChange="@HandleTagsChange"
                                                Tags="@Tags"/>

                                            <DynamicAIMode 
                                                FeatureName=@CurrentFeatureName
                                                CurrentSetting=@ChatSetting
                                                OnChatSettingRadioChange="@HandleChatSettingRadioChange" 
                                                />  
                                        </FluentStack>

                                        <FluentStack Orientation="Orientation.Horizontal" HorizontalAlignment="@Horizontal"
                                        VerticalAlignment="@Vertical" HorizontalGap="1">
                                        </FluentStack>  

                                        <DynamicAIStatus 
                                            FeatureName=@CurrentFeatureName
                                            MasterTextSetting=@masterTextSetting
                                            ChatSetting=@ChatSetting
                                            WritingStyleVal=@AICopilotSettings.WritingStyleVal 
                                            AudienceLevelVal=@AICopilotSettings.AudienceLevelVal
                                            ResponseLengthVal=@AICopilotSettings.ResponseLengthVal
                                            CreativeAdjustmentsVal=@AICopilotSettings.CreativeAdjustmentsVal 
                                            ResponseStyleVal=@AICopilotSettings.ResponseStyleVal
                                            RelationSettingsVal=@AICopilotSettings.RelationSettingsVal 
                                            ImageSetting=@ImageSetting />
                                        <FluentButton IconEnd="@(new Icons.Regular.Size20.ArrowReset())" Title="Reset Settings"
                                                    OnClick="AICopilotSettingsReset" />


                                            <DynamicInputField 
                                            Value="@UserInput" 
                                            ValueChanged="@((value) => { 
                                                UserInput = value; 
                                                StateHasChanged(); // Ensure state is updated
                                            })"
                                            OnSubmit="@HandleSubmit" 
                                            Placeholder="@PlaceholderCommandText" 
                                            Rows="@Rows" 
                                            MinLength="6"
                                            MaxLength="16384" 
                                            Autofocus="@Autofocus" 
                                            Submitting="@Submitting" />   
                                
                                    </FluentToolbar>    
                                </FluentMultiSplitterPane>
                               
                                <!-- COMMAND Line Pane END -->
                            </FluentMultiSplitter>
                        </FluentMultiSplitterPane>
                        <!-- MIDDLE Pane END -->
                        <!-- Button Pane -->
                        <FluentMultiSplitterPane Size="@RightPaneSize" Min="30%" Collapsible="false">
                            @if (!isRightPaneCollapsed)
                            {
                                <FluentCard MinimalStyle="true" Width="calc(100% - 40px)" Style="border: 1px solid var(--accent-fill-rest); padding: 0px; margin-right: 40px;"
                                    Class="fluent-card-summary-details">
                                    
                                    <FluentAccordion ActiveId="@activeId" OnAccordionItemChange="HandleOnAccordionItemChange" ExpandMode="AccordionExpandMode.Single">
                                        <!--
                                        @if (OntologyTree != null && OntologyTree.Any()){
                                            <FluentAccordionItem Heading="Ontologies" Class="accordion-heading fluent-accordion-item">
                                                <FluentIcon Value="@(new Icons.Regular.Size20.Globe())" Color="@Color.Accent" Slot="start" />
                                                <FluentCard  Height="100%"  style="padding: 0px; max-height: 90vh; overflow-y: auto; background-color: #f7f7f7;">

                                                    <FluentLabel Typo="Typography.Body" Class="content-small-font-size">
                                                    <b>@currentSelectedOntologyTitle</b> 
                                                    </FluentLabel>                    
                                                    <FluentLabel Typo="Typography.Body" Class="content-small-font-size">
                                                    @currentSelectedTreeItemOntology?.Text
                                                    </FluentLabel>
                                                    <FluentTreeView 
                                                    @bind-CurrentSelected="@currentSelectedTreeViewItemOntology"
                                                    OnSelectedChange="@HandleOnSelectedChangeOntology" Class="tree-font-size">
                                                        @foreach (var chapter in OntologyTree)
                                                        {
                                                            <FluentTreeItem InitiallyExpanded="false" Text="@(chapter.GetTitle())">
                                                                @foreach (var section in chapter.Sections)
                                                                {
                                                                    <FluentTreeItem InitiallyExpanded="false" Text="@(section.GetTitle())" Id="@(section.GetId())">
                                                                    </FluentTreeItem>
                                                                }
                                                            </FluentTreeItem>
                                                        }
                                                    </FluentTreeView>
                                                </FluentCard>
                                            </FluentAccordionItem>
                                        }
                                        
                                        -->
                                        <FluentLabel Typo="Typography.Subject">
                                            @CurrentFeatureWorkflowName: <b>@CurrentFeatureName</b>
                                        </FluentLabel>
                                        <FluentAccordionItem Heading="Tasks" Class="accordion-heading fluent-accordion-item">
                                            <FluentIcon Value="@(new Icons.Regular.Size20.SparkleCircle())" Color="@Color.Accent" Slot="start" />
                                            <FluentTreeView bind-CurrentSelected="currentSelectedTreeItemAICopilots" OnSelectedChange="HandleOnSelectedChangeAICopilots" Class="tree-font-size">
                                                @foreach (var component in filteredComponentsAICopilots)
                                                {
                                                    <FluentTreeItem InitiallyExpanded="false" Text="@component.Name">
                                                        <FluentIcon Value="@component.Icon" Color="Color.Neutral" Slot="start" />
                                                        @foreach (var subComponent in component.SubComponents)
                                                        {
                                                            <FluentTreeItem Text="@subComponent.Name" Id="@subComponent.Id">
                                                                <FluentIcon Value="@subComponent.Icon" Color="Color.Accent" Slot="start" />
                                                            </FluentTreeItem>
                                                        }
                                                    </FluentTreeItem>
                                                }
                                            </FluentTreeView>
                                        </FluentAccordionItem>
                                        <FluentAccordionItem Expanded="true" Heading="Settings" Class="accordion-heading fluent-accordion-item">
                                            <FluentIcon Value="@(new Icons.Regular.Size20.Settings())" Color="@Color.Accent" Slot="start" />
                                            <FluentLabel Typo="Typography.Subject">
                                                <b>@currentSelectedTreeItemAICopilotSettings?.Text</b> 
                                            </FluentLabel>
                                            <div style="max-height: 640px; overflow-y: auto;">
                                                <FluentTreeView bind-CurrentSelected=currentSelectedTreeItemAICopilotSettings OnSelectedChange="HandleOnSelectedChangeAICopilotSettings" >
                                                    @foreach (var component in componentsAICopilotSettings)
                                                    {
                                                        <FluentTreeItem InitiallyExpanded="false" Text="@component.Name" Class="tree-font-size">
                                                            <FluentIcon Value="@component.Icon" Color="Color.Neutral" Slot="start" />
                                                            @foreach (var subComponent in component.SubComponents)
                                                            {
                                                                <FluentTreeItem Text="@subComponent.Name" Id="@subComponent.Id" Class="tree-font-size">
                                                                    <FluentIcon Value="@subComponent.Icon" Color="Color.Neutral" Slot="start" />
                                                                </FluentTreeItem>
                                                            }
                                                        </FluentTreeItem>
                                                    }
                                                </FluentTreeView>
                                            </div>
                                        </FluentAccordionItem>
                                    </FluentAccordion>
                                </FluentCard>
                            }
                        </FluentMultiSplitterPane>

                         <!-- RIGHT Pane BEGIN -->
                        <FluentMultiSplitterPane Size="@RightPaneSize" Min="30%" Collapsible="false">
                        
                        </FluentMultiSplitterPane>
                        <!-- RIGHT Pane END -->

                    </FluentMultiSplitter>
                </div>
            </Content>
    </FluentTab>
     <FluentTab Id="Reference-id">
    <Header>
        Reference
    </Header>
        <Content>
        </Content>
    </FluentTab>
</FluentTabs> 
<style>
    .splitter-container {
        height: 100vh;
        overflow: hidden;
    }
</style>
@code {
    [Parameter]
    public string FeatureNameProject { get; set; } = "AIWriting";

   [Parameter]
    public string FeatureUserFriendlyName { get; set; } = "AI Writing Assistant";
    
    [Parameter]
    public string FeatureDescription { get; set; } = "AIWriting";

   [Parameter]
    public string? TemplateName { get; set; }
   
   [Parameter]
    public bool IsProject { get; set; }  = false;
    
    [Parameter]
    public string RawDataOntologies { get; set; } = "";

    [Parameter]
    public string PanelInput { get; set; } = "";


    [Parameter]
    public EventCallback OnNavBarVisibilityUpdated { get; set; }

    [Parameter]
    public EventCallback<string> OnChatUpdated { get; set; }
        
    [Parameter]  
    public EventCallback<string> OnUserInputSubmit { get; set; }

    [Parameter]  
    public bool showLEFTPane  { get; set; } = false;
        
    [Parameter]  
    public bool showINPUTPane  { get; set; } = true;
    
    [Parameter]
    public string currentUserTenantID   { get; set; }

    [Parameter]
    public string? currentUserIdentityID   { get; set; }

    [Parameter]
    public string? userEmail   { get; set; }
    
    [Parameter]
    public string? displayName   { get; set; }
    
    [Parameter]
    public string? timeZoneInfo   { get; set; }

   [Parameter]
    public string? userTimeZone   { get; set; }
    [Parameter]
    public DateTime userLocalTime   { get; set; }
   [Parameter]
    public string? userLanguage   { get; set; }

    [Parameter]
    public string? c { get; set; }

    [Parameter]
    public EventCallback<string> OnFeatureNameChanged { get; set; }
    
    private FileItemRow _selectedFile;
    
    [Parameter]
    public FileItemRow SelectedFile
    {
        get => _selectedFile;
        set
        {
            if (_selectedFile != value)
            {
                _selectedFile = value;

                if (_selectedFile != null)
                {
                }
                else
                {
                    // Clear the OntologyTree if SelectedFile is null
                    OntologyTree = null;
                }
            }
        }
    }
     private string _selectedFileContent;

    [Parameter]
    public string SelectedFileContent
    {
        get => _selectedFileContent;
        set
        {
            if (_selectedFileContent != value)
            {
                _selectedFileContent = value;

                if (!string.IsNullOrWhiteSpace(_selectedFileContent))
                {
                    // Parse the content only if SelectedFileContent is not null or empty
                    OntologyTree = ParseOntologyTreeMarkdown(_selectedFileContent);
                    //Console.WriteLine($"SelectedFile OntologyTree: {_selectedFileContent}");
                }
                else
                {
                    // Clear the OntologyTree if SelectedFileContent is null or empty
                    OntologyTree = null;
                    Console.WriteLine("SelectedFileContent is empty, clearing OntologyTree");
                }

                // Trigger a re-render
                StateHasChanged();
            }
        }
    }
    private int inputTokenCount = 0;
    private int outputTokenCount = 0;
    private int totalTokenCount = 0;
    private bool cacheHit = false;

    private ElementReference containerDiv;

    private bool isLeftPaneCollapsed = false;
    private bool isRightPaneCollapsed = false;

    private bool isHtmlView = false;
    private string LeftPaneSize => isLeftPaneCollapsed ? "40px" : CalculateLeftPaneSize();
    private string FluentCardWidth => CalculateFluentCardWidth();
    private string MiddlePaneSize => CalculateMiddlePaneSize();
    private string RightPaneSize => isRightPaneCollapsed ? "40px" : "20%";
    
    private string CalculateLeftPaneSize()
    {
        return activeid switch
        {
            //"Github-id" => "20%", // Adjust this value based on your preference
            "ConversationalMemory-id" => "20%", // Default size for Threads
            _ => "20%", // Fallback size
        };
    }
    private string CalculateFluentCardWidth()
    {
        return activeid switch
        {
            //"Github-id" => "820px", // Wide width for Github Repositories
            "ConversationalMemory-id" => "340px", // Narrow width for Threads
            _ => "340px", // Fallback width
        };
    }
        private string CalculateMiddlePaneSize()
        {
            if (isLeftPaneCollapsed && isRightPaneCollapsed) return "calc(100% - 80px)";
            if (isLeftPaneCollapsed) return "calc(100% - 30px - 15%)"; // 15% for right pane and 30px for collapsed left pane
            if (isRightPaneCollapsed) return "calc(100% - 20% - 30px)"; // 20% for left pane and 30px for collapsed right pane
            return "calc(100% - 20% - 15% - 60px)"; // 20% for left pane, 15% for right pane, and 60px for both panes
        }

    private void ToggleLeftPane()
    {
        isLeftPaneCollapsed = !isLeftPaneCollapsed;
    }
    private void ToggleRightPane()
    {
        isRightPaneCollapsed = !isRightPaneCollapsed;
    }
    private bool isShowFullAgentsChatThreadVisible = false;
    public string CurrentFeatureWorkflowName { get; set; } = "Writing";

    public string CurrentFeatureName { get; set; } = "AIWritingAssistant";
    //public string CurrentTaskWorkflowName { get; set; } = "Current Task";

    string masterTextSetting = "Ask"; // Ask, Correct, Improve, Content
    string ChatSetting = "OneShot"; // OneShot
    
    private Profile profile;
    private UserAccountInformation accountInfo;

    string ImageSetting = "Photo"; //
    private string DBKey = null;

    bool oneShotSetting = true;
    string UserInput { get; set; } = string.Empty;
    string UserInputSaved = "";

    public bool Autofocus { get; set; } = true;
    private bool Submitting { get; set; } = false;

   private ITreeViewItem? currentSelectedTreeItemMessages = null;

    private FluentTreeItem? currentSelectedTreeItemAICopilotSettings = null;
    private FluentTreeItem? currentSelectedTreeItemAICopilots = null;

    public string PlaceholderInputText { get; set; } = "Enter your input (data, text, information, or code) here for AI to process.";
    public string PlaceholderOutputText { get; set; } = "The AI will display the processed output here for your review and analysis.";

    public string PlaceholderCommandText { get; set; } = "Ask AI Assistant.";

    private int Rows { get; set; } = 24;
    public int RowsCommand = 12;

    string PanelInputTemp = null;

    private string PanelOutputFinal { get; set; } = "";

    private string ProcessedPanelOutputFinal { get; set; }

    private MarkupString ProcessedPanelOutputFinalHTML { get; set; } = (MarkupString)string.Empty;


    public string PanelOutput { get; set; } = "";
    
    private bool IsDarkMode { get; set; } = false;

    private string ProcessedPanelOutput { get; set; }

    private MarkupString ProcessedPanelOutputHTML { get; set; } = (MarkupString)string.Empty;

    private string RecipientEmails { get; set; }

    private bool PanelOutputSwitchValue { get; set; } =false;

    private bool PanelOutputFinalSwitchValue { get; set; } =false;


    private string? UserPromptSet { get; set; }
    private string? CollectionName { get; set; }
    private string? imageUrl;

    private bool _loadingComplete;
    string? comboboxValue;
    string InputMessage = "";
    string ResultMessage = "";
    public string FeatureNamePipeline { get; set; } = "";
    public string FeatureFriendlyNameCurrent { get; set; } = "";
    bool useVectorSearch = false;

    string callFunctionTemp = "";

    private string topicType = "";

    private string backdropType = "";//
    private string backdropTypeDescription = "";
    private string lightingType = "";//
    private string lightingTypeDescription = "";//

    private string photostyleType = "";//
    private string photostyleTypeDescription = "";//

    private string photoshotType = "";//
    private string photoshotTypeDescription = "";//

    private string imageContentType = "Art";// Photo, Graphic, Art
    private string imageSize = "Landscape"; // Square=1024x1024, Landscape=1024x1792 or Vertical=1792x1024
    private string imageGenerationQuality = "High Definition"; // Normal, High Definition


    bool webSearchUse = false;
    bool IsMyKnowledgeBaseChecked = false;

    private string pluginDir = "";
    string imageSettingMenu = "Text To Photo";

    private string imageGenerationStyle = "Vivid"; // Standard, Vivid

    private string pastedImageBase64 = string.Empty;

    private string imageBase64 = string.Empty;

    private List<DiagramOption> diagramOptions = new();
    private DiagramOption selectedDiagramOption;
    private string selectedDiagramValue;
    List<MenuItemOneLevel> menuItemsDiagrams = new List<MenuItemOneLevel>();
    public string FeatureName { get; set; } = null;

    public string FeatureName1 { get; set; } = null;
    public string FeatureName2 { get; set; } = null;
    public string FeatureName3 { get; set; } = null;
    private void HandleTagsChange(string newTags)
    {
        Tags = newTags; // Update the tags
        Console.WriteLine($"Tags: {Tags}");
    }

    public async ValueTask DisposeAsync()
    {
        // Implement any cleanup logic here if needed
        await ValueTask.CompletedTask;
    }
}

@code{
        private async Task HandleMasterTextSettingRadioChange(string newSetting)
    {
        var newSettingCommandPlaceholder = MasterTextSettingsService.CreateCommandPlaceholderForMasterTextSetting(newSetting);

        masterTextSetting = newSetting;
        Console.WriteLine($"MasterTextSetting: {masterTextSetting}");
        if (masterTextSetting == "Help")
        {
            PlaceholderCommandText = $"Ask to {newSettingCommandPlaceholder}";
        } else if (masterTextSetting == "Ask"){
            PlaceholderCommandText = $"Ask {CurrentFeatureName} to {newSettingCommandPlaceholder}";

        } else if (masterTextSetting == "Correct"){
            PlaceholderCommandText = $"Ask {CurrentFeatureName} to {newSettingCommandPlaceholder}";

        } else if (masterTextSetting == "Improve"){
            PlaceholderCommandText = $"Ask {CurrentFeatureName} to {newSettingCommandPlaceholder}";

        } else if (masterTextSetting == "Content"){
            PlaceholderCommandText = $"Ask {CurrentFeatureName} to {newSettingCommandPlaceholder}";

        }       
        await Task.CompletedTask;
    }
    private async Task HandleMyKnowledgeBaseCheckedChange(bool isChecked)
    {
        IsMyKnowledgeBaseChecked = isChecked;
        Console.WriteLine($"IsMyKnowledgeBaseChecked: {IsMyKnowledgeBaseChecked}");
    }
    private async Task HandleChatSettingRadioChange(ChatSettings settings)
    {
        ChatSetting = settings.ChatSetting;
        oneShotSetting = settings.OneShotSetting;
        //ChatSettingRadioChangeResultMessage = $"Chat setting: {settings.ChatSetting}, One-shot: {settings.OneShotSetting}";
        // ChatSetting: OneShot
        // ChatSetting: Pipeline
        Console.WriteLine($"ChatSetting: {ChatSetting}");

        if (ChatSetting == "Workflow")
        {
            UserInputSaved = UserInput;
            string CurrentThreadId = CurrentThread.Id; 
            string workflow = await azureOpenAIHandler.LoadThreadMessagesPipeAsync(CurrentThreadId);
            UserInput=($"Workflow: {workflow}");
        } else{
            UserInput=UserInputSaved;
            //currentSelectedTreeItemAICopilots  = null;
            await InvokeAsync(StateHasChanged);
        }
        await Task.CompletedTask;
    }
    public string PipeDelimited()
    {
        string pipeDelimitedString = string.Join("|", 
            //currentUserIdentityID, 
            //CurrentFeatureName, 
            //PanelInput, 
            //userInput, 
            masterTextSetting, 
            ChatSetting,
            AICopilotSettings.WritingStyleVal, 
            AICopilotSettings.AudienceLevelVal, 
            AICopilotSettings.ResponseLengthVal, 
            AICopilotSettings.CreativeAdjustmentsVal, 
            AICopilotSettings.RelationSettingsVal, 
            AICopilotSettings.ResponseStyleVal
        );
        return pipeDelimitedString;
    }
    public void  AICopilotSettingsReset()
    {
        AICopilotSettings.WritingStyleVal = ""; 
        AICopilotSettings.AudienceLevelVal= ""; 
        AICopilotSettings.ResponseLengthVal= "1024"; 
        AICopilotSettings.CreativeAdjustmentsVal= "Focused"; 
        AICopilotSettings.RelationSettingsVal= ""; 
        AICopilotSettings.ResponseStyleVal= ""; 
    }
    bool isNewThread = true;
    private string GetFormattedThreadTitle(string text)
    {
        // Count the number of dashes in the text
        int dashCount = text.Count(c => c == '-');

        // Only remove the date part if there are at least 2 dashes
        if (dashCount >= 2)
        {
            // Assuming the date is always in the format "yyyyMMdd-HHmmss-"
            int dateEndIndex = text.IndexOf('-', text.IndexOf('-') + 1) + 1;
            if (dateEndIndex < text.Length)
            {
                text = text.Substring(dateEndIndex);
            }
        }

        // Return the processed text, truncated if necessary
        return text.Length > 22 ? text.Substring(0, 22) : text;
    }
    private string GetFormattedThreadFullTitle(string text)
    {
        // Count the number of dashes in the text
        int dashCount = text.Count(c => c == '-');

        // Only remove the date part if there are at least 2 dashes
        if (dashCount >= 2)
        {
            // Assuming the date is always in the format "yyyyMMdd-HHmmss-"
            int dateEndIndex = text.IndexOf('-', text.IndexOf('-') + 1) + 1;
            if (dateEndIndex < text.Length)
            {
                text = text.Substring(dateEndIndex);
            }
        }

        // Return the processed text, truncated if necessary
        return  text;
    }
    string timeTaken;
    public List<ChatMessageM> ChatMessages { get; set; } = new();
    private async Task HandleSubmit()
    {
        string userInput = UserInput;
        string panelInput = PanelInput;

        Submitting = true;
        //@if (selectedSectionContentFinal != null)
        //{
        //    panelInput = "Reference: " + selectedSectionContentFinal + "\n\n" + panelInput+ "\n\n" ;
        //}
        Console.WriteLine($"HandleSubmit userInput: {userInput}");
        Console.WriteLine($"HandleSubmit threadSelectedName {threadSelectedName}");
        if (SelectedFile != null)
        {
            panelInput = SelectedFileContent + "\n\n" + panelInput;
        }
        // Concatenate values into a pipe-delimited string
        string pipeDelimitedString = string.Join("|",
            currentUserIdentityID,
            CurrentFeatureWorkflowName,
            CurrentFeatureName,
            panelInput,
            userInput,
            masterTextSetting,
            AICopilotSettings.ResponseLengthVal,
            AICopilotSettings.CreativeAdjustmentsVal,
            AICopilotSettings.AudienceLevelVal,
            AICopilotSettings.WritingStyleVal,
            AICopilotSettings.RelationSettingsVal,
            AICopilotSettings.ResponseStyleVal
        );

        Console.WriteLine($"HandleSubmit currentChatThreadId: {currentChatThreadId}");
        // Get the output from AzureOpenAIHandler
        (string responseOutput, double timeSpent) = await azureOpenAIHandler.HandleSubmitAsync(
            isNewThread,
            IsMyKnowledgeBaseChecked,
            currentUserTenantID,
            currentUserIdentityID,
            CurrentFeatureWorkflowName,
            CurrentFeatureName,
            panelInput,
            userInput,
            Tags,
            masterTextSetting,
            AICopilotSettings.ResponseLengthVal,
            AICopilotSettings.CreativeAdjustmentsVal,
            AICopilotSettings.AudienceLevelVal,
            AICopilotSettings.WritingStyleVal,
            AICopilotSettings.RelationSettingsVal,
            AICopilotSettings.ResponseStyleVal,
            threadSelectedName,
            currentChatThreadId
        );
        // Format a user-friendly string with the response and time spent
        /// Format the time taken as a user-friendly string
        timeTaken = timeSpent < 60 
            ? $"{timeSpent:F2} seconds" 
            : $"{(timeSpent / 60):F2} minutes";

        Submitting = false;
        PanelOutput = responseOutput;
        agentSettings = _agentConfigurationService.GetAgentSettings(CurrentFeatureName);

        if (agentSettings != null)
        {
            // Retrieve agent settings for the given project feature

            try
            {
                // Parse the JSON response into a list of messages
                ChatMessages = Newtonsoft.Json.JsonConvert.DeserializeObject<List<ChatMessageM>>(PanelOutput);

                // Format the final CopyWriter content with more prominent styling
                if (!string.IsNullOrEmpty(agentSettings.EditorRoleName)) {
                    PanelOutput = FormatProminentWriterContent(
                        ChatMessages.LastOrDefault(m => m.Author == agentSettings.EditorRoleName)?.Content ?? "No message from CopyWriter found."
                    );
                } else {
                    PanelOutput = FormatProminentWriterContent(
                        ChatMessages.LastOrDefault(m => m.Author == agentSettings.WriterRoleName)?.Content ?? "No message from CopyWriter found."
                    );
                }
            }
            catch (Newtonsoft.Json.JsonSerializationException ex)
            {
                Console.WriteLine($"Error deserializing response JSON: {ex.Message}");
                PanelOutput = "Failed to process the response. Please try again later.";
            }
        }

        await LoadThreadsAsync(currentChatThreadId);
    }
    private Icon IconCollapsed = new Icons.Regular.Size20.Folder();
    private Icon IconExpanded = new Icons.Regular.Size20.FolderOpen();

    private async Task LoadThreadsAsync(string? threadIdToSelect = null)
    {
        List<Cosmos.Copilot.Models.ThreadChat> ThreadChats = await azureOpenAIHandler.LoadThreadsAsync(
            currentUserTenantID,
            currentUserIdentityID, 
            CurrentFeatureWorkflowName);

        ItemsThreads = ThreadChats.Select(thread => new TreeViewItem
        {
            Text = thread.Title,
            Id = thread.Id,
            IconCollapsed = IconCollapsed,
            IconExpanded = IconExpanded,
            OnExpandedAsync = OnExpandedAsync,
            Expanded = false,
            Items = TreeViewItem.LoadingTreeViewItems,
        }).Cast<ITreeViewItem>().ToList();

        if (ItemsThreads.Any())
        {
            // Find the thread to select based on the provided ID or default to the last Thread
            var selectedThreadChat = threadIdToSelect != null 
                ? ThreadChats.FirstOrDefault(s => s.Id == threadIdToSelect) 
                : ThreadChats.LastOrDefault();

            if (selectedThreadChat != null)
            {
                CurrentThread = new Thread
                {
                    Name = selectedThreadChat.Title,
                    Id = selectedThreadChat.Id
                };
                threadSelectedName = selectedThreadChat.Title;
                threadSelectedItemName = null;
                
                var selectedTreeItem = ItemsThreads.FirstOrDefault(item => item.Id == selectedThreadChat.Id);
                SelectedItem = selectedTreeItem;
                Console.WriteLine($"LoadThreadsAsync: CurrentThread Id {CurrentThread.Id}");
                Console.WriteLine($"LoadThreadsAsync: CurrentThread Title {CurrentThread.Name}");

                await ExpandAndSelectLastChatInThreadAsync(CurrentThread.Id);
            }
        }
        else
        {
            // Clear the selected item
            SelectedItem = null;

            // Set the new Thread flag
            isNewThread = true;

            //await LoadThreadsAsync();
            threadSelectedName = null;
            currentChatThreadId = string.Empty;
            threadSelectedItemName = null;
        }
    }
    
    private async Task OnExpandedAsync(TreeViewItemExpandedEventArgs e)
    {
        if (e.Expanded)
        {
            Console.WriteLine($"OnExpandedAsync e.CurrentItem.Id: {e.CurrentItem.Id}");

            e.CurrentItem.Items = await azureOpenAIHandler.LoadThreadMessagesAsync(
            currentUserTenantID,
            currentUserIdentityID,
            e.CurrentItem.Id);
        }
        else
        {
            e.CurrentItem.Items = TreeViewItem.LoadingTreeViewItems;
        }

        // Trigger UI update
        //StateHasChanged();
    }

    private async Task ExpandAndSelectLastChatInThreadAsync(string threadId)
    {
        // Find the corresponding TreeViewItem for the thread
        var threadItem = ItemsThreads.FirstOrDefault(item => item.Id == threadId);
        if (threadItem != null)
        {
            // Manually trigger the loading of the thread's messages
            threadItem.Items = await azureOpenAIHandler.LoadThreadMessagesAsync(
                currentUserTenantID,
                currentUserIdentityID, 
                threadId);

            // Set the Thread to be expanded
            threadItem.Expanded = true;

            // Select the last chat item if available
            var lastChatItem = threadItem.Items.LastOrDefault();
            if (lastChatItem != null)
            {
                await OnItemSelectedAsync(lastChatItem.Id);
            }
        }
    }



    string threadSelectedName;
    private void HandleSelectedThreadItemChanged(FluentTreeItem selectedTreeItem)
    {
        if (selectedTreeItem == null)
        {
            Console.WriteLine("Error: No item selected.");
            return;
        }
        timeTaken="";
        _ = OnItemSelectedAsync(selectedTreeItem.Id); // Fire-and-forget to avoid blocking UI
        isNewThread = false;
    }


     private string currentChatThreadId = string.Empty; 
    private string currentChatThreadItemMessageId = string.Empty; 


    string threadSelectedItemName;
    private async Task OnItemSelectedAsync(string selectedItemId)
    {
        Console.WriteLine($"OnItemSelectedAsync: {selectedItemId}");

        // Split the ID by '|' to isolate the parts
        var parts = selectedItemId.Split('|');

        if (parts.Length >= 1)
        {
            isNewThread = false;

            currentChatThreadId = parts[0];
             var selectedThreadChat = await azureOpenAIHandler.GetThreadAsync(
                currentUserTenantID,
                currentUserIdentityID, 
                currentChatThreadId);
            if (selectedThreadChat != null)
            {
                threadSelectedName = selectedThreadChat.Title;
                //StateHasChanged();
            }

            Console.WriteLine($"Current Selected Tree Item Messages ID: {currentChatThreadId}");
        }
        else
        {
            Console.WriteLine("Error: Invalid ID format. Expected at least one part separated by '|'.");
            return;
        }

        string? messageId = null;

        // Check if there's a second part which should be the message ID
        if (parts.Length >= 2)
        {
            var messageIdPart = parts[1];
            if (messageIdPart.StartsWith("Message-"))
            {
                messageId = messageIdPart;
                Console.WriteLine($"Extracted Message ID: {messageId}");
            }
            else
            {
                Console.WriteLine("Warning: Second part does not start with 'Message-'. Ignoring message ID.");
            }
        }

        if (!string.IsNullOrEmpty(messageId))
        {
            currentChatThreadItemMessageId = messageId;
            // **Message Selection Scenario**
            // Fetch the message details using the extracted message ID
            var message = await azureOpenAIHandler.GetMessageByIdAsync(messageId);
            if (message != null)
            {
                threadSelectedItemName = message.Title;
                // Display the message content
                PanelInput = message.Prompt;
                PanelOutput = message.Output;

                inputTokenCount = message.InputTokenCount;
                outputTokenCount = message.OutputTokenCount;
                totalTokenCount = message.TotalTokenCount;

                cacheHit = message.CacheHit;

                //StateHasChanged();

                // Set Thread-related settings based on message details
                CurrentFeatureWorkflowName = message.FeatureNameWorkflowName ?? string.Empty;
                CurrentFeatureName = message.FeatureNameProject ?? string.Empty;

                AICopilotSettings.WritingStyleVal = message.WritingStyleVal ?? string.Empty;
                AICopilotSettings.AudienceLevelVal = message.AudienceLevelVal ?? string.Empty;
                AICopilotSettings.ResponseLengthVal = message.ResponseLengthVal ?? string.Empty;
                AICopilotSettings.CreativeAdjustmentsVal = message.CreativeAdjustmentsVal ?? string.Empty;
                AICopilotSettings.RelationSettingsVal = message.RelationSettingsVal ?? string.Empty;
                AICopilotSettings.ResponseStyleVal = message.ResponseStyleVal ?? string.Empty;

                // Update UI with new data
                //StateHasChanged();
            }
            else
            {
                Console.WriteLine($"Message not found for ID: {messageId}");
            }
        }
        else
        {
            // **No Message Selected Scenario**
            // Optionally, you can handle cases where only the Thread ID is present
            // Since you mentioned not needing the else block, we leave this section empty
            // However, you might still want to perform some actions or simply acknowledge the selection
            Console.WriteLine($"Selected Item is a Thread with ID: {currentChatThreadId}, but no specific message selected.");
        }
    }

    // Define a class to match the JSON structure
    public class RequestData
    {
        public string FeatureNameWorkflowName { get; set; }
        public string FeatureNameProject { get; set; }

        public string PanelInput { get; set; }
        public string Input { get; set; }
        public string Tags { get; set; }
        public string MasterTextSetting { get; set; }
        public string ResponseLength { get; set; }
        public string CreativeAdjustments { get; set; }
        public string AudienceLevel { get; set; }
        public string WritingStyle { get; set; }
        public string RelationSettings { get; set; }
        public string ResponseStyle { get; set; }
    }



    private void HandleOnSelectedSelectThread(FluentTreeItem selectedItem)
    {
        //SelectedItem = selectedItem;
        Console.WriteLine($"Selected selectedItem.Id: {selectedItem.Id}");
        Console.WriteLine($"Selected selectedItem.Text: {selectedItem.Text}");
    }

    // Method to get background color based on author
    private string GetBackgroundColor(string author)
    {
        return author switch
        {
            "CopyWriter" => "#f0f4fc",   // Light blue for CopyWriter
            "MarketingDirector" => "#fff5f5",  // Light red/pink for Marketing
            _ => "#f9f9f9",              // Default background color
        };
    }
    private string FormatProminentWriterContent(string content)
    {
        // Replace the Markdown-style bold syntax with HTML bold tags
        return content = content.Replace("**- Final Message:**", "<strong>- Final Message:</strong>");
/*
        return $@"
        <div style='
            font-size:12px;
            line-height:1.7;
            color:#2c3e50;
            background-color:#eef6fc;
            padding:20px;
            border-left:5px solid #4A90E2;
            border-radius:8px;
            margin-top:20px;
            '>
            <span style='font-size:18px; color:#1a73e8; font-weight:bold;'>Final Copy:</span>
            <br><br>
            <div style='font-size:16px; line-height:1.8; color:#333;'>
                {content}
            </div>
            <br><br>
            <em style='color:#95a5a6;'>End of Message</em>
        </div>";
        */
    }

    // Convert Markdown to HTML
    private string ConvertMarkdownToHtml(string markdown)
    {
        var html = Markdown.ToHtml(markdown);

        // Customize styles for markdown elements
        html = html.Replace("<strong>", "<strong style='font-weight:bold; color:#1a73e8;'>");
        html = html.Replace("<p>", "<p style='margin-bottom:1em;'>");
        html = html.Replace("<em>", "<em style='color:#95a5a6;'>");

        // Additional styling for blockquotes, code blocks, etc.
        // Example:
        html = html.Replace("<blockquote>", "<blockquote style='margin-left:20px; color:#555;'>");

        return html;
    }

    private async Task StartNewThread()
    {
        // Clear the necessary fields
        PanelInput = string.Empty;
        UserInput = string.Empty;
        PanelOutput = string.Empty;

        // Clear the selected item
        SelectedItem = null;

        // Set the new Thread flag
        isNewThread = true;

        //await LoadThreadsAsync();
        threadSelectedName = null;
        currentChatThreadId = string.Empty;
        threadSelectedItemName = null;
    }
    HorizontalAlignment Horizontal;
    VerticalAlignment Vertical;

}
@code {
        public string GetSecondPart(string input)
        {
            // Split the input string by '/'
            var parts = input.Split('/');

            // Return the second part if it exists
            return parts.Length > 1 ? parts[1] : string.Empty;
        }
     
        private async Task DeleteThread(string threadStringId)
        {
            Console.WriteLine($"DeleteThread: {threadStringId}");
            var idParts = threadStringId.Split('|');
            // Case 1: Deleting a full Thread
            // Delete the entire Thread and its messages
            string tenantId = currentUserTenantID;
            string userId = currentUserIdentityID;
            await azureOpenAIHandler.DeleteChatThreadAsync(tenantId, userId, threadStringId);

            // Log and update UI after deletion
            Console.WriteLine($"Deleted Thread: {threadStringId}");

            threadSelectedName = null;
            currentChatThreadId = string.Empty;
            threadSelectedItemName = null;

            await LoadThreadsAsync();
            StateHasChanged();
        }
         private async Task DeleteThreadItem(string threadItemId)
        {
            Console.WriteLine($"threadItemId: {threadItemId}");
            // Extract tenantId, userId, threadId, and messageId
            string tenantId = currentUserTenantID;
            string userId = currentUserIdentityID;
            string threadId = currentChatThreadId;

            // Delete the specific message from the Thread
            await azureOpenAIHandler.DeleteMessageAsync(tenantId, userId, threadId, threadItemId);

            // Log and update UI after deletion
            Console.WriteLine($"Deleted message: {threadItemId}");
            threadSelectedItemName = null;

            await LoadThreadsAsync();
            StateHasChanged();
        }
}


@code {
    //private string? displayName;
    //private string userEmail = "konstantine@aitrailblazer.com";
    //private string userFullName;
    private string userPhoneNumer;
    private string userAddress;
    private string userPrincipalJson = "default-principal";
    private string pluginPath;
     private IEnumerable<string> pluginFiles = Enumerable.Empty<string>();

    private bool isInitialized = false;
    private string? Tags;

    private ITreeViewItem? SelectedItem;
    private IEnumerable<ITreeViewItem>? ItemsThreads = new List<ITreeViewItem>();
    private List<Thread> Threads = new();
    private Thread? CurrentThread { get; set; }
    private AgentSettings agentSettings;

       protected override async Task OnInitializedAsync()
    {
        if (!isInitialized)
        {
            await LoadUserDataAsync();
            isInitialized = true;
        }
    }
    private async Task LoadUserDataAsync()
    {

        //var (userId, tenantId) = await UserIDsService.GetUserIDsAsync();
        //currentUserIdentityID = userId;
        //currentUserTenantID = tenantId;

        pluginPath = PluginService.GetPluginsPath();
        //Console.WriteLine($"ChatPaneSplitter Plugin Path: {pluginPath}");

        //Console.WriteLine($"ChatPaneSplitter OnInitializedAsync CurrentFeatureName: {CurrentFeatureName}");

        PlaceholderCommandText = $"Give AI your instructions or choose from the Tasks menu.";
        
        agentSettings = _agentConfigurationService.GetAgentSettings(CurrentFeatureName);

        FilterComponents(FeatureNameProject);
        await LoadThreadsAsync();
    }
}


@code{


    public void TriggerParseOntologyTree(string markdownText)
    {
        OntologyTree = ParseOntologyTreeMarkdown(markdownText);
        StateHasChanged(); // Refresh the UI
    }
}


@code {
    private List<Chapter> OntologyTree = new List<Chapter>();
    private List<OntologyTreeViewItem> treeViewItems = new List<OntologyTreeViewItem>();
    private string currentSelectedTreeViewItemOntology;
    private FluentTreeItem? currentSelectedTreeItemOntology;

    private string selectedSectionContent = string.Empty;
    private string selectedSectionContentFinal = string.Empty;
    //private string activeId = "0"; // Default active accordion ID
    private string currentSelectedOntologyTitle  = string.Empty; 
    protected override void OnInitialized()
    {
        // Load and parse the markdown document
        //var markdownText = System.IO.File.ReadAllText("GitHub_SoftwareDocumentation.md");
        OntologyTree = ParseOntologyTreeMarkdown(_selectedFileContent);
        treeViewItems = OntologyTree.Select(c => new OntologyTreeViewItem(c)).ToList();
    }

 /// <summary>
/// Parses the ontology tree from markdown text, handling bold and italic markers.
/// </summary>
private List<Chapter> ParseOntologyTreeMarkdown(string markdownText)
{
    var chapters = new List<Chapter>();
    var lines = markdownText.Split('\n');

    Chapter? currentChapter = null;
    Section? currentSection = null;
    SubSection? currentSubSection = null;

    // Root-level title (for example, # Pitch Deck)
    string? rootTitle = null;

    foreach (var line in lines)
    {
        var trimmedLine = line.Trim();

        // Handle root title (single #), which is treated as the full document header
        if (trimmedLine.StartsWith("# "))
        {
            // This is the root-level item, save the title (e.g., "Pitch Deck")
            rootTitle = trimmedLine.Substring(2).Trim(new[] { '*', ' ', '_' });
        }
        // Handle chapter titles (## level)
        else if (trimmedLine.StartsWith("## "))
        {
            var title = trimmedLine.Substring(3).Trim(new[] { '*', ' ', '_' });
            currentChapter = new Chapter
            {
                Title = title,
                Sections = new List<Section>()
            };
            chapters.Add(currentChapter);
            currentSection = null;
            currentSubSection = null;
        }
        // Handle section titles (### level)
        else if (trimmedLine.StartsWith("### "))
        {
            if (currentChapter == null)
            {
                // Handle sections without a parent chapter
                continue;
            }

            var sectionTitle = trimmedLine.Substring(3).Trim(new[] { '*', ' ', '_' });
            currentSection = new Section
            {
                Title = sectionTitle,
                SubSections = new List<SubSection>()
            };
            currentChapter.AddSection(currentSection);
            currentSubSection = null;
        }
        // Handle subsections (- list items)
        else if (trimmedLine.StartsWith("- "))
        {
            if (currentSection == null)
            {
                // Handle subsections without a parent section
                continue;
            }

            var subSectionParts = trimmedLine.Substring(2).Split(new[] { ':' }, 2);
            var subSectionTitle = subSectionParts[0].Trim(new[] { '*', ' ', '_' });
            var subSectionContent = subSectionParts.Length > 1 ? subSectionParts[1].Trim() : string.Empty;

            currentSubSection = new SubSection
            {
                Title = subSectionTitle,
                Content = subSectionContent
            };
            currentSection.AddSubSection(currentSubSection);
        }
        // Handle continuation of subsection content
        else if (currentSubSection != null && !string.IsNullOrWhiteSpace(trimmedLine))
        {
            currentSubSection.Content += " " + trimmedLine;
        }
    }

    // If a root title was found, store it somewhere (e.g., as a separate root item in the tree or metadata)
    if (!string.IsNullOrEmpty(rootTitle))
    {
        Console.WriteLine($"Root title detected: {rootTitle}");
        // Optionally, you could add this as a special Chapter or RootItem in your data model
    }

    return chapters;
}
    private void HandleOnSelectedChangeOntology(FluentTreeItem selectedTreeItem)
    {
        if (Guid.TryParse(selectedTreeItem.Id, out Guid selectedId))
        {
            // Log the selected TreeItem ID for debugging
            Console.WriteLine($"HandleOnSelectedChangeOntology selectedTreeItem.Id: {selectedId}");
            Console.WriteLine($"HandleOnSelectedChangeOntology selectedTreeItem.Text: {selectedTreeItem.Text}");
            // 1. Introduction
            currentSelectedOntologyTitle = selectedTreeItem.Text;
            // Find and display content based on the selected TreeItem's Guid ID
            FindAndDisplayOntologyContent(selectedId);
        }
        else
        {
            Console.WriteLine($"Failed to parse selectedTreeItem.Id: {selectedTreeItem.Id}");
        }
    }

    private void FindAndDisplayOntologyContent(Guid selectedId)
    {
        // Find the corresponding tree item based on the Guid ID
        var selectedItem = OntologyTree
            .SelectMany(chapter => new[] { chapter as ITreeItem }
                .Concat(chapter.Sections)
                .Concat(chapter.Sections.SelectMany(section => section.SubSections)))
            .FirstOrDefault(item => item.Id == selectedId); // Match by Guid

        if (selectedItem != null)
        {
            switch (selectedItem)
            {
                case Chapter chapter:
                    if (IsRootChapter(chapter)) // Check if it's the root
                    {
                        selectedSectionContentFinal = GenerateFullOntologyContent(); // Copy the full document
                    }
                    else
                    {
                        selectedSectionContentFinal = GenerateChapterContent(chapter); // Handle chapter
                    }
                    break;

                case Section section:
                    var parentChapter = OntologyTree.FirstOrDefault(ch => ch.Sections.Contains(section)); // Find parent chapter
                    if (parentChapter != null)
                    {
                        selectedSectionContentFinal = GenerateSectionContent(section, parentChapter); // Pass section and parent chapter
                    }
                    break;

                case SubSection subSection:
                    var parentSection = OntologyTree.SelectMany(ch => ch.Sections)
                                                    .FirstOrDefault(sec => sec.SubSections.Contains(subSection)); // Find parent section
                    var parentChapterForSubSection = OntologyTree.FirstOrDefault(ch => ch.Sections.Contains(parentSection)); // Find parent chapter
                    if (parentSection != null && parentChapterForSubSection != null)
                    {
                        selectedSectionContentFinal = GenerateSubSectionContent(subSection, parentSection, parentChapterForSubSection); // Pass subSection, parentSection, and parentChapter
                    }
                    break;

                default:
                    selectedSectionContentFinal = "No content available.";
                    break;
            }

            Console.WriteLine($"Displaying content for selected ID: {selectedId}");
            Console.WriteLine($"Selected Section Content: {selectedSectionContentFinal}");
        }
        else
        {
            Console.WriteLine($"No matching item found for selected ID: {selectedId}");
        }
    }
    private bool IsRootChapter(Chapter chapter)
    {
        // Assuming the first chapter in the list is the root representing the full document
        return OntologyTree.FirstOrDefault() == chapter;
    }

    // Method to generate the content for the full ontology tree (entire document)
    private string GenerateFullOntologyContent()
    {
        var fullContentBuilder = new StringBuilder();

        // Iterate over each chapter and its sections/subsections
        foreach (var chapter in OntologyTree)
        {
            fullContentBuilder.AppendLine(GenerateChapterContent(chapter));
        }

        return fullContentBuilder.ToString();
    }

    private async Task HandleOnSelectedChangeOntology1()
{
    Logger.LogInformation($"HandleOnSelectedChangeOntology called. Current selected ID: {currentSelectedTreeViewItemOntology}");

    if (string.IsNullOrEmpty(currentSelectedTreeViewItemOntology))
    {
        Logger.LogWarning("currentSelectedTreeViewItemOntology is null or empty. No selection made.");
        return;
    }

    if (OntologyTree == null || !OntologyTree.Any())
    {
        Logger.LogWarning("OntologyTree is null or empty.");
        return;
    }

    // Find the selected item in the tree
    var selectedTreeViewItem = OntologyTree
        .SelectMany(chapter => new[] { chapter as ITreeItem }.Concat(chapter.Sections)
            .Concat(chapter.Sections.SelectMany(section => section.SubSections)))
        .FirstOrDefault(item => item.Id.ToString() == currentSelectedTreeViewItemOntology);

    if (selectedTreeViewItem != null)
    {
        currentSelectedOntologyTitle = selectedTreeViewItem.Title;
        Logger.LogInformation($"Selected Item: {selectedTreeViewItem.Title}");
        selectedSectionContentFinal = string.Empty;

        // Handle the content based on heading level
        selectedSectionContentFinal = GetContentForHeadingFromTree(selectedTreeViewItem);
        
        Logger.LogInformation($"Selected Section Content: {selectedSectionContentFinal}");
    }
    else
    {
        Logger.LogWarning($"Selected item not found in OntologyTree. ID: {currentSelectedTreeViewItemOntology}");
    }
}
private string GetContentForHeadingFromTree(ITreeItem selectedTreeViewItem)
{
    // Traverse the OntologyTree to find the selected heading and extract content dynamically
    StringBuilder contentBuilder = new StringBuilder();

    // Traverse the chapters, sections, and subsections to build the content based on the selected item
    bool isWithinSelectedSection = false;

    foreach (var chapter in OntologyTree)
    {
        if (chapter == selectedTreeViewItem)
        {
            // Copy the entire chapter content if it's the selected heading (e.g., # Software Documentation Ontologies)
            contentBuilder.Append(GenerateChapterContent(chapter));
            return contentBuilder.ToString();
        }

        foreach (var section in chapter.Sections)
        {
            if (section == selectedTreeViewItem)
            {
                // Begin copying the content between this section and the next section of the same level
                isWithinSelectedSection = true;
                contentBuilder.Append(GenerateSectionContent(section, chapter));
            }
            else if (isWithinSelectedSection)
            {
                // Stop copying once the next section or chapter is encountered
                return contentBuilder.ToString();
            }

            foreach (var subSection in section.SubSections)
            {
                if (subSection == selectedTreeViewItem)
                {
                    // Begin copying content for the selected subsection
                    isWithinSelectedSection = true;
                    contentBuilder.Append(GenerateSubSectionContent(subSection, section, chapter));
                }
                else if (isWithinSelectedSection)
                {
                    // Stop copying at the next subsection or higher-level heading
                    return contentBuilder.ToString();
                }
            }
        }
    }

    return contentBuilder.ToString();
}
private string GenerateChapterContent(Chapter chapter)
{
    StringBuilder chapterContent = new StringBuilder();
    chapterContent.AppendLine($"# {chapter.Title}");

    foreach (var section in chapter.Sections)
    {
        chapterContent.AppendLine(GenerateSectionContent(section, chapter));
    }

    return chapterContent.ToString();
}
private string GenerateSectionContent(Section section, Chapter chapter)
{
    StringBuilder sectionContent = new StringBuilder();
    sectionContent.AppendLine($"## {section.Title}");

    foreach (var subSection in section.SubSections)
    {
        sectionContent.AppendLine(GenerateSubSectionContent(subSection, section, chapter));
    }

    return sectionContent.ToString();
}
private string GenerateSubSectionContent(SubSection subSection, Section section, Chapter chapter)
{
    StringBuilder subSectionContent = new StringBuilder();
    subSectionContent.AppendLine($"### {subSection.Title}");
    subSectionContent.AppendLine(subSection.Content); // Assuming subSection.Content has the actual text content.

    return subSectionContent.ToString();
}

    /// <summary>
    /// Generates the final content for a selected Chapter.
    /// </summary>
    private string GenerateChapterFinalContent(Chapter chapter)
    {
        var contentBuilder = new StringBuilder();
        contentBuilder.AppendLine($"# {chapter.Title}");
        foreach (var section in chapter.Sections)
        {
            contentBuilder.AppendLine($"## {section.Title}");
            foreach (var subSection in section.SubSections)
            {
                contentBuilder.AppendLine($"{subSection.ContentFinal}");
            }
        }
        return contentBuilder.ToString();
    }


    private void HandleOnAccordionItemChange(string newActiveId)
    {
        activeId = newActiveId;
    }
}

@code {
    string? activeid = "ConversationalMemory-id";
    string currenttab = "ConversationalMemory-id";
    private async Task HandleOnTabChange(FluentTab tab)
    {
        currenttab = tab.Id;
        Console.WriteLine($"ChatPaneSplitter HandleOnTabChange Tab changed to {tab.Id}");


    }

      // Declare OnUpdateFileContent as an EventCallback if it's passed from another component
    [Parameter] public EventCallback<string> OnUpdateFileContent { get; set; }

// This method handles loading file content and assigns it to PanelInput
    private void HandleFileContentLoaded(string fileContent)
    {
        PanelInput = fileContent; // Assign file content to PanelInput
        StateHasChanged(); // Update the UI
    }



    // This method handles loading issue content and assigns it to PanelInput
    private void HandleIssueContentLoaded(string issueContent)
    {
        PanelInput = issueContent; // Assign issue content to PanelInput
        StateHasChanged(); // Update the UI
    }
    public string GetPanelOutput()
    {
        //Console.WriteLine($"GetPanelOutput invoked, returning: {PanelOutput}");

        return PanelOutput;
    }

     private void TestDelegate()
    {
        var output = GetPanelOutput();
        Console.WriteLine($"TestDelegate: {output}");
    }


}

@code {
    string? activeid1 = "Work-id"; //  Reference-id
    FluentTab? changedto;

    private void HandleOnMainTabChange(FluentTab tab)
    {
        changedto = tab;
        Console.WriteLine($"HandleOnMainTabChange: Tab changed to: {tab.Id}");
        if (tab.Id == "Work-id")
        {
            //activeid = "Work-id";
        }
        else if (tab.Id == "Reference-id")
        {
            //Console.WriteLine($"HandleOnMainTabChange SelectedChangeOntology: {currentSelectedTreeItemOntology.Id}");

            //SelectedChangeOntology(currentSelectedTreeItemOntology);
        }
    }
        private async Task PanelOutputFinalReport(string contentToCopy)
    {
        loadingOutput6 = true;
        StateHasChanged(); // Notify Blazor to re-render the UI with the loading state

        await Task.Delay(2000);

        loadingOutput6 = false;
        StateHasChanged(); // Notify Blazor to re-render the UI after loading is complete
    }
        private void HandlePanelOutputFinalSwitch(ChangeEventArgs e)
    {
        Console.WriteLine($"Switch value: {PanelOutputFinalSwitchValue}");

        if (PanelOutputFinalSwitchValue)
        {
            Console.WriteLine("Switch on - Edit mode");
        }
        else
        {
            Console.WriteLine("Switch off - View mode");
        }
        ProcessPanelOutputFinal();
    }
        private void ProcessPanelOutputFinal()
    {
        string inputString1 = FormattingUtility.RemoveParametersTags(PanelOutputFinal);
        if (masterTextSetting == "Image")
        {
            ProcessedPanelOutputFinal = PanelOutputFinal;
            Console.WriteLine($"Processed ProcessedPanelOutputFinal: {ProcessedPanelOutputFinal}");
        } else if ((FeatureNamePipeline == "AIDiagramCodex") || (FeatureNameProject == "AIDiagramCodex")) {
            string remainderString = FormattingUtility.ExtractRemainderString(inputString1, "##########");
            ProcessedPanelOutputFinal = remainderString;
 
            Console.WriteLine($"Processed PanelOutput: {ProcessedPanelOutputFinal}");
        } else {
                ProcessedPanelOutputFinalHTML= (MarkupString)FormattingUtility.RenderMarkdownToHtml(PanelOutputFinal);
                                
                Console.WriteLine($"ProcessedPanelOutputFinalHTML: {ProcessedPanelOutputFinalHTML}");

         }
    }
    [Parameter]
    public EventCallback OnClearReference { get; set; }

    private void ClearReference()
    {
        // Clear local properties
        SelectedFile = null;
        SelectedFileContent = string.Empty;

        selectedSectionContent = string.Empty;
        selectedSectionContentFinal = string.Empty;

        currentSelectedTreeItemOntology = null;
        currentSelectedOntologyTitle = null;


        // Notify the parent that the references should be cleared as well
        if (OnClearReference.HasDelegate)
        {
            OnClearReference.InvokeAsync();
        }

        StateHasChanged(); // Refresh the component if necessary
    }
    private void ClearReferenceSelection()
    {
        selectedSectionContentFinal = string.Empty;
        currentSelectedOntologyTitle = string.Empty;   
        currentSelectedTreeItemOntology = null;
    }
}

@code {

    private bool loadingOutput1 = false;
    private bool loadingOutput2 = false;
    private bool loadingOutput3 = false;
    private bool loadingOutput4 = false;
    private bool loadingOutput5 = false;
    private bool loadingOutput6 = false;

    private void ClearPanelInput()
    {
        PanelInput = string.Empty;
    }

    private void ClearPanelOutput()
    {
        PanelOutput = string.Empty;
    }
 
    private async Task CopyToClipboard()
    {
        if (!string.IsNullOrEmpty(PanelOutput))

        loadingOutput1 = true;
        StateHasChanged(); // Notify Blazor to re-render the UI with the loading state

        await JSRuntime.InvokeVoidAsync("navigator.clipboard.writeText", PanelOutput);

        // Wait for 2000 milliseconds (2 seconds)
        await Task.Delay(2000);

        loadingOutput1 = false;
        StateHasChanged(); // Notify Blazor to re-render the UI after loading is complete
    }
    private async Task CopyOutputToInput()
    {
        if (!string.IsNullOrEmpty(PanelOutput))
            {
            loadingOutput2 = true;
            StateHasChanged(); // Notify Blazor to re-render the UI with the loading state

            PanelInput = PanelOutput;

            // Wait for 2000 milliseconds (2 seconds)
            await Task.Delay(2000);

            loadingOutput2 = false;
            StateHasChanged(); // Notify Blazor to re-render the UI after loading is complete
        }
    }
}


@code{

    string activeId = "accordion-1";

    FluentAccordionItem? changed;

    private void HandleOnAccordionItemChange(FluentAccordionItem item)
    {
        changed = item;
    }
        private void HandleOnSelectedChangeAICopilotSettings(FluentTreeItem selectedTreeItem)
    {

        currentSelectedTreeItemAICopilotSettings = selectedTreeItem;
        Console.WriteLine($"currentSelectedTreeItemAICopilotSettings: {currentSelectedTreeItemAICopilotSettings.Id}");

        var parts = currentSelectedTreeItemAICopilotSettings.Id.Split('_');
        if (parts.Length == 2)
        {
            HandleSelectedChangeAICopilotSettings(parts[0], parts[1]);
        }
        else
        {
            Console.WriteLine($"Invalid selected item ID format: {currentSelectedTreeItemAICopilotSettings.Id}");
        }
    }
    private void HandleSelectedChangeAICopilotSettings(string componentName, string value)
    {
        // Log the state before change
        Console.WriteLine($"Before Change: WritingStyle={AICopilotSettings.WritingStyleVal}, AudienceLevel={AICopilotSettings.AudienceLevelVal}, ResponseLength={AICopilotSettings.ResponseLengthVal}, CreativeAdjustments={AICopilotSettings.CreativeAdjustmentsVal}, RelationSettings={AICopilotSettings.RelationSettingsVal}, ResponseStyle={AICopilotSettings.ResponseStyleVal}");

        switch (componentName)
        {
            case "ResponseLength":
                AICopilotSettings.ResponseLengthVal = value;  // No toggle logic here
                break;
            case "CreativeAdjustments":
                AICopilotSettings.CreativeAdjustmentsVal = value;  // No toggle logic here
                break;
            case "WritingStyle":
                AICopilotSettings.WritingStyleVal = value;
                break;
            case "AudienceLevel":
                AICopilotSettings.AudienceLevelVal = value;
                break;
            case "RelationSettings":
                AICopilotSettings.RelationSettingsVal = value;
                break;
            case "ResponseStyle":
                AICopilotSettings.ResponseStyleVal = value;
                break;
            default:
                Console.WriteLine($"Unknown component name: {componentName}");
                break;
        }

        // Log the state after change
        Console.WriteLine($"After Change: WritingStyle={AICopilotSettings.WritingStyleVal}, AudienceLevel={AICopilotSettings.AudienceLevelVal}, ResponseLength={AICopilotSettings.ResponseLengthVal}, CreativeAdjustments={AICopilotSettings.CreativeAdjustmentsVal}, RelationSettings={AICopilotSettings.RelationSettingsVal}, ResponseStyle={AICopilotSettings.ResponseStyleVal}");

        string pipeDelimitedString = PipeDelimited();
        Console.WriteLine($"pipeDelimitedString {pipeDelimitedString}");
    }

    private string searchQuery = string.Empty;
    private List<ComponentModel> componentsAICopilotSettings = new List<ComponentModel>
    {
        new ComponentModel 
        { 
            Name = "Writing Style", 
            Id = "WritingStyle", 
            Icon = new Icons.Regular.Size20.Book(), 
            SubComponents = new List<ComponentModel>
            {
                new ComponentModel { Name = "Casual", Id = "WritingStyle_Casual", Icon = new Icons.Regular.Size24.People() },
                new ComponentModel { Name = "Formal", Id = "WritingStyle_Formal", Icon = new Icons.Regular.Size24.Briefcase() },
                new ComponentModel { Name = "Technical", Id = "WritingStyle_Technical", Icon = new Icons.Regular.Size24.Code() },
                new ComponentModel { Name = "Persuasive", Id = "WritingStyle_Persuasive", Icon = new Icons.Regular.Size24.Megaphone() },
                new ComponentModel { Name = "Narrative", Id = "WritingStyle_Narrative", Icon = new Icons.Regular.Size24.BookOpen() },
                new ComponentModel { Name = "Exhaustive", Id = "WritingStyle_Exhaustive", Icon = new Icons.Regular.Size24.ReadingList() },
                new ComponentModel { Name = "Comprehensive", Id = "WritingStyle_Comprehensive", Icon = new Icons.Regular.Size24.ClipboardTaskListLtr() },
                new ComponentModel { Name = "Detailed", Id = "WritingStyle_Detailed", Icon = new Icons.Regular.Size24.Search() },
                new ComponentModel { Name = "Concise", Id = "WritingStyle_Concise", Icon = new Icons.Regular.Size24.ContractDownLeft() },
                new ComponentModel { Name = "Laconic", Id = "WritingStyle_Laconic", Icon = new Icons.Regular.Size24.Cut() }
            }
        },
        new ComponentModel 
        { 
            Name = "Audience Level", 
            Id = "AudienceLevel", 
            Icon = new Icons.Regular.Size20.PeopleAudience(), 
            SubComponents = new List<ComponentModel>
            {
                new ComponentModel { Name = "Novice", Id = "AudienceLevel_Novice", Icon = new Icons.Regular.Size24.BookOpen() },
                new ComponentModel { Name = "Intermediate", Id = "AudienceLevel_Intermediate", Icon = new Icons.Regular.Size24.LightbulbPerson() },
                new ComponentModel { Name = "Advanced", Id = "AudienceLevel_Advanced", Icon = new Icons.Regular.Size24.BrainCircuit() },
                new ComponentModel { Name = "Superior", Id = "AudienceLevel_Superior", Icon = new Icons.Regular.Size24.Trophy() },
                new ComponentModel { Name = "Distinguished", Id = "AudienceLevel_Distinguished", Icon = new Icons.Regular.Size24.Ribbon() }
            }
        },
        new ComponentModel 
        { 
            Name = "Response Length (Tokens)", 
            Id = "ResponseLength", 
            Icon = new Icons.Regular.Size20.DocumentFit(),
            SubComponents = new List<ComponentModel>
            {
                new ComponentModel { Name = "16", Id = "ResponseLength_16", Icon = new Icons.Regular.Size24.DocumentFit() },
                new ComponentModel { Name = "32", Id = "ResponseLength_32", Icon = new Icons.Regular.Size24.DocumentFit() },
                new ComponentModel { Name = "64", Id = "ResponseLength_64", Icon = new Icons.Regular.Size24.DocumentFit() },
                new ComponentModel { Name = "128", Id = "ResponseLength_128", Icon = new Icons.Regular.Size24.DocumentFit() },
                new ComponentModel { Name = "256", Id = "ResponseLength_256", Icon = new Icons.Regular.Size24.DocumentFit() },
                new ComponentModel { Name = "512", Id = "ResponseLength_512", Icon = new Icons.Regular.Size24.DocumentFit() },
                new ComponentModel { Name = "1024", Id = "ResponseLength_1024", Icon = new Icons.Regular.Size24.DocumentFit() },
                new ComponentModel { Name = "2048", Id = "ResponseLength_2048", Icon = new Icons.Regular.Size24.DocumentFit() },
                new ComponentModel { Name = "4096", Id = "ResponseLength_4096", Icon = new Icons.Regular.Size24.DocumentFit() },
                new ComponentModel { Name = "8192", Id = "ResponseLength_8192", Icon = new Icons.Regular.Size24.DocumentFit() },
                new ComponentModel { Name = "16384", Id = "ResponseLength_16384", Icon = new Icons.Regular.Size24.DocumentFit() }            }
                        },
        new ComponentModel 
        { 
            Name = "Creative Adjustments", 
            Id = "CreativeAdjustments", 
            Icon = new Icons.Regular.Size16.Target(),
            SubComponents = new List<ComponentModel>
            {
                new ComponentModel { Name = "Focused", Id = "CreativeAdjustments_Focused", Icon = new Icons.Regular.Size16.Target() },
                new ComponentModel { Name = "Analytical", Id = "CreativeAdjustments_Analytical", Icon = new Icons.Regular.Size24.Lightbulb() },
                new ComponentModel { Name = "Balanced", Id = "CreativeAdjustments_Balanced", Icon = new Icons.Regular.Size24.Scales() },
                new ComponentModel { Name = "Adaptable", Id = "CreativeAdjustments_Adaptable", Icon = new Icons.Regular.Size24.ScaleFit() },
                new ComponentModel { Name = "Open", Id = "CreativeAdjustments_Open", Icon = new Icons.Regular.Size24.Globe() },
                new ComponentModel { Name = "Inspired", Id = "CreativeAdjustments_Inspired", Icon = new Icons.Regular.Size24.BrainCircuit() },
                new ComponentModel { Name = "Creative", Id = "CreativeAdjustments_Creative", Icon = new Icons.Regular.Size24.PaintBrush() },
                new ComponentModel { Name = "Innovative", Id = "CreativeAdjustments_Innovative", Icon = new Icons.Regular.Size24.Rocket() },
                new ComponentModel { Name = "Visionary", Id = "CreativeAdjustments_Visionary", Icon = new Icons.Regular.Size24.EyeTracking() }
            }
        },
        new ComponentModel 
        {
            Name = "Relation Settings", 
            Id = "RelationSettings", 
            Icon = new Icons.Regular.Size20.LightbulbCircle(),
            SubComponents = new List<ComponentModel>
            {
                new ComponentModel { Name = "Peer-to-Peer", Id = "RelationSettings_PeerToPeer", Icon = new Icons.Regular.Size24.People() },
                new ComponentModel { Name = "Upward", Id = "RelationSettings_Upward", Icon = new Icons.Regular.Size24.ArrowUp() },
                new ComponentModel { Name = "Downward", Id = "RelationSettings_Downward", Icon = new Icons.Filled.Size24.ArrowDown() },
                new ComponentModel { Name = "Customer", Id = "RelationSettings_Customer", Icon = new Icons.Regular.Size24.ContactCard() },
                new ComponentModel { Name = "Partner", Id = "RelationSettings_Partner", Icon = new Icons.Regular.Size24.Handshake() },
                new ComponentModel { Name = "Investor", Id = "RelationSettings_Investor", Icon = new Icons.Regular.Size24.Money() },
                new ComponentModel { Name = "Public Relations", Id = "RelationSettings_PublicRelations", Icon = new Icons.Regular.Size24.Globe() },
                new ComponentModel { Name = "Crisis", Id = "RelationSettings_Crisis", Icon = new Icons.Regular.Size24.Warning() },
                new ComponentModel { Name = "Instructional", Id = "RelationSettings_Instructional", Icon = new Icons.Regular.Size24.BookOpen() },
                new ComponentModel { Name = "Motivational", Id = "RelationSettings_Motivational", Icon = new Icons.Regular.Size24.Star() },
                new ComponentModel { Name = "Innovative", Id = "RelationSettings_Innovative", Icon = new Icons.Regular.Size24.Lightbulb() }
            }
        },
        new ComponentModel 
        {
            Name = "Response Style", 
            Id = "ResponseStyle", 
            Icon = new Icons.Regular.Size20.Edit(),
            SubComponents = new List<ComponentModel>
            {
                new ComponentModel { Name = "Summary", Id = "ResponseStyle_Summary", Icon = new Icons.Regular.Size24.BookInformation() },
                new ComponentModel { Name = "Alternatives", Id = "ResponseStyle_Alternatives", Icon = new Icons.Regular.Size24.ArrowSwap() },
                new ComponentModel { Name = "Elaborate", Id = "ResponseStyle_Elaborate", Icon = new Icons.Regular.Size24.TextParagraph() },
                new ComponentModel { Name = "Compare", Id = "ResponseStyle_Compare", Icon = new Icons.Regular.Size24.Scales() },
                new ComponentModel { Name = "Clarify", Id = "ResponseStyle_Clarify", Icon = new Icons.Regular.Size24.Search() },
                new ComponentModel { Name = "Predict", Id = "ResponseStyle_Predict", Icon = new Icons.Regular.Size24.WeatherSunny() },
                new ComponentModel { Name = "Synthesize", Id = "ResponseStyle_Synthesize", Icon = new Icons.Regular.Size24.BranchFork() },
                new ComponentModel { Name = "Question", Id = "ResponseStyle_Question", Icon = new Icons.Regular.Size24.QuestionCircle() },
                new ComponentModel { Name = "Reflect", Id = "ResponseStyle_Reflect", Icon = new Icons.Regular.Size24.Thinking() },
                new ComponentModel { Name = "Strict", Id = "ResponseStyle_Strict", Icon = new Icons.Regular.Size24.CheckmarkSquare() },
                new ComponentModel { Name = "Innovate", Id = "ResponseStyle_Innovate", Icon = new Icons.Regular.Size24.LightbulbCircle() }
            }
        }
    };

}


@code {
    private List<ComponentModel> componentsAICopilots = new List<ComponentModel>
    {
        new ComponentModel
        {
            WorkflowName = "Writing",
            Name = "Writing",
            Icon = new Icons.Regular.Size20.DocumentOnePageSparkle(),
            SubComponents = new List<ComponentModel>
            {
                new ComponentModel { Name = AICopilotDescriptionService.GetFriendlyNameForAICopilotService("AIWritingAssistant"), WorkflowName = "Writing", Id = "AIWritingAssistant", Icon = new Icons.Regular.Size20.Pen() },
                new ComponentModel { Name = AICopilotDescriptionService.GetFriendlyNameForAICopilotService("AIKeyPointsWizard"), WorkflowName = "Writing", Id = "AIKeyPointsWizard", Icon = new Icons.Regular.Size20.AppsList() },
                new ComponentModel { Name = AICopilotDescriptionService.GetFriendlyNameForAICopilotService("AIClearNote"), WorkflowName = "Writing", Id = "AIClearNote", Icon = new Icons.Regular.Size20.BookStar() },
                new ComponentModel { Name = AICopilotDescriptionService.GetFriendlyNameForAICopilotService("AIEmailWizard"), WorkflowName = "Writing", Id = "AIEmailWizard", Icon = new Icons.Regular.Size20.Mail() },
                new ComponentModel { Name = AICopilotDescriptionService.GetFriendlyNameForAICopilotService("AIInternalMemo"), WorkflowName = "Writing", Id = "AIInternalMemo", Icon = new Icons.Regular.Size20.StarEmphasis() },
                new ComponentModel { Name = AICopilotDescriptionService.GetFriendlyNameForAICopilotService("AIMessageOptimizer"), WorkflowName = "Writing",  Id = "AIMessageOptimizer", Icon = new Icons.Regular.Size20.EmojiEdit() },
                new ComponentModel { Name = AICopilotDescriptionService.GetFriendlyNameForAICopilotService("AINamesGen"), WorkflowName = "Writing", Id = "AINamesGen", Icon = new Icons.Regular.Size20.TextCaseTitle()},  
                new ComponentModel { Name = AICopilotDescriptionService.GetFriendlyNameForAICopilotService("AiTaskWizard"), WorkflowName = "Writing", Id = "AiTaskWizard", Icon = new Icons.Regular.Size20.TextCaseTitle()}
            }
        },
        new ComponentModel
        {
            WorkflowName = "CodeAndDocumentation",
            Name = "Code & Documentation",
            Icon = new Icons.Regular.Size20.GlanceHorizontalSparkles(),
            SubComponents = new List<ComponentModel>
            {
                new ComponentModel { Name = AICopilotDescriptionService.GetFriendlyNameForAICopilotService("AIOntologyGen"), WorkflowName = "CodeAndDocumentation",Id = "AIOntologyGen", Icon = new Icons.Regular.Size20.DocumentBulletListMultiple() },
                new ComponentModel { Name = AICopilotDescriptionService.GetFriendlyNameForAICopilotService("AIReportGen"), WorkflowName = "CodeAndDocumentation", Id = "AIReportGen", Icon = new Icons.Regular.Size20.DocumentBulletListMultiple() },
                new ComponentModel { Name = AICopilotDescriptionService.GetFriendlyNameForAICopilotService("AISoftwareDocGen"), WorkflowName = "CodeAndDocumentation", Id = "AISoftwareDocGen", Icon = new Icons.Regular.Size20.DocumentBulletListMultiple() },
                new ComponentModel { Name = AICopilotDescriptionService.GetFriendlyNameForAICopilotService("AISoftwareCodeGen"), WorkflowName = "CodeAndDocumentation", Id = "AISoftwareCodeGen", Icon = new Icons.Regular.Size20.DocumentBulletListMultiple() },
                new ComponentModel { Name = AICopilotDescriptionService.GetFriendlyNameForAICopilotService("COSE"), WorkflowName = "CodeAndDocumentation", Id = "COSE", Icon = new Icons.Regular.Size20.BrainCircuit() },
                //new ComponentModel { Name = AICopilotDescriptionService.GetFriendlyNameForAICopilotService("AIDiagramCodex"), Id = "AIDiagramCodex", Icon = new Icons.Regular.Size20.BrainCircuit() }
            }
        },
        new ComponentModel
        {
            WorkflowName = "StrategicInsights",
            Name = "Strategic Insights",
            Icon = new Icons.Regular.Size20.FlashSparkle(),
            SubComponents = new List<ComponentModel>
            {
                new ComponentModel { Name = AICopilotDescriptionService.GetFriendlyNameForAICopilotService("AIStrategiX"), WorkflowName = "StrategicInsights", Id = "AIStrategiX", Icon = new Icons.Regular.Size20.Chess() },
                new ComponentModel { Name = AICopilotDescriptionService.GetFriendlyNameForAICopilotService("AIInSightOut"), WorkflowName = "StrategicInsights",  Id = "AIInSightOut", Icon = new Icons.Regular.Size20.BuildingLighthouse() }
            }
        },
        new ComponentModel
        {
            WorkflowName = "Visuals",
            Name = "Visuals",
            Icon = new Icons.Regular.Size20.GlanceHorizontalSparkles(),
            SubComponents = new List<ComponentModel>
            {
                new ComponentModel { Name = AICopilotDescriptionService.GetFriendlyNameForAICopilotService("AILightRayArt"), WorkflowName = "Visuals",  Id = "AILightRayArt", Icon = new Icons.Regular.Size20.DesignIdeas() },
                new ComponentModel { Name = AICopilotDescriptionService.GetFriendlyNameForAICopilotService("AIVideoPromptGen"), WorkflowName = "Visuals", Id = "AIVideoPromptGen", Icon = new Icons.Regular.Size20.VideoChat() }                }
        },
    };

    private List<ComponentModel> filteredComponentsAICopilots = new List<ComponentModel>();
    public void FilterComponents(string FeatureNameProject)
    {
        if (FeatureNameProject == "AIContent")
        {
            CurrentFeatureName="AIWritingAssistant";
            filteredComponentsAICopilots = componentsAICopilots
                .Where(component => component.Name == "Writing" || 
                component.Name == "Code & Documentation" ||
                component.Name == "Strategic Insights"
                )
                .ToList();
        } 
    }
    private async Task  HandleOnSelectedChangeAICopilots(FluentTreeItem selectedTreeItem)
    {
        // Check if the selected tree item text is one of the values to skip
        var skipTexts = new[] { "Writing", "Code & Documentation", "Strategic Insights", "Visuals" };
        if (skipTexts.Contains(selectedTreeItem.Text))
        {
            // If the text is in the skip list, exit the method without assigning or processing further
            return;
        }

        currentSelectedTreeItemAICopilots = selectedTreeItem;
        Console.WriteLine($"currentSelectedTreeItemAICopilots Text: {currentSelectedTreeItemAICopilots.Text}");

        Console.WriteLine($"currentSelectedTreeItemAICopilots Id: {currentSelectedTreeItemAICopilots.Id}");
        CurrentFeatureName=currentSelectedTreeItemAICopilots.Id;
        Console.WriteLine($"HandleOnSelectedChangeAICopilots CurrentFeatureName: {CurrentFeatureName}");
        await OnFeatureNameChanged.InvokeAsync(CurrentFeatureName);
        agentSettings = _agentConfigurationService.GetAgentSettings(CurrentFeatureName);
 
        HandleSelectedChangeAICopilots(currentSelectedTreeItemAICopilots.Id);

        // Append selected tree item text if it is not already present
        //if (!UserInput.Contains(currentSelectedTreeItemAICopilots.Id))
        //{
        //    UserInput += 
        //    AICopilotDescriptionService.GetFriendlyNameForAICopilotService(currentSelectedTreeItemAICopilots.Id) + " | ";
        //}

        // Split, trim, and remove duplicates
        var pipelines = UserInput.Split(new[] { " | " }, StringSplitOptions.RemoveEmptyEntries)
                                .Select(p => p.Trim())
                                .Distinct();
                                 // Clear existing Threads before reloading
        //await LoadThreadsAsync();

        // Rejoin the items to update UserInput string properly
        //UserInput = string.Join(" | ", pipelines) + " | ";
        // Update wizard steps
        //LoadWizardSteps(UserInput);
    }
    private void HandleSelectedChangeAICopilots(string componentId)
    {
        // Find the component by ID
        // AIWritingAssistant -> "Writing Assistant"
        ComponentModel selectedComponent = FindComponentById(componentsAICopilots, componentId);

        // Check if the component was found
        if (selectedComponent != null)
        {
            string featureFriendlyNameCurrent=selectedComponent.Name;
            CurrentFeatureWorkflowName=selectedComponent.WorkflowName;
            // Retrieve the raw data from the KnowledgeDocument
            //if (CurrentFeatureWorkflowName == "CodeAndDocumentation"){
            //    RawDataOntologies = KnowledgeDocument.GoProjectStructureOntologies;
            //    Console.WriteLine($"OnParametersSetAsync: RawDataOntologies: {RawDataOntologies}");
            //    OntologyTree = ParseOntologyTreeMarkdown(RawDataOntologies);
            //}

            // OntologyTree = ParseOntologyTreeMarkdown(SelectedFileContent);
            UpdateFeatureInfo(featureFriendlyNameCurrent);
            // Retrieve agent settings for the given project feature
            agentSettings = _agentConfigurationService.GetAgentSettings(CurrentFeatureName);
        }
        else
        {
            // Log if the component was not found
            Console.WriteLine($"Component not found for ID: {componentId}");
        }
    }
    private List<WizardStep> WizardSteps = new List<WizardStep>();


    private void LoadWizardSteps(string dataSource)
    {
        WizardSteps.Clear(); // Clear existing steps
        StateHasChanged(); // Notify the UI to update
        dataSource = dataSource.Replace("Pipeline: ", "");
        var stepsArray = dataSource.Split(new[] { " | " }, StringSplitOptions.RemoveEmptyEntries)
        .Distinct();
        //var stepsArray = dataSource.Split('|');

        foreach (var stepName in stepsArray)
        {
            Console.WriteLine($"LoadWizardSteps stepName {stepName}");           
            string SystemName = AICopilotDescriptionService.GetSystemNameForAICopilotService(stepName);
            string Description = AICopilotDescriptionService.GetLabelForAICopilotDescriptionService(SystemName);
            string featureFriendlyNameCurrent="";
            Console.WriteLine($"LoadWizardSteps: featureFriendlyNameCurrent: {featureFriendlyNameCurrent}");
            WizardSteps.Add(new WizardStep
            {
                Label = stepName.Trim(),
                //Summary = $"Summary for {featureFriendlyNameCurrent.Trim()}",
                Content = builder => { builder.AddContent(0, $"{Description}"); }
            });
        }
    }
    private ComponentModel FindComponentById(List<ComponentModel> components, string id)
    {
        foreach (var component in components)
        {
            if (component.Id == id)
                return component;

            var subComponent = FindComponentById(component.SubComponents, id);
            if (subComponent != null)
                return subComponent;
        }
        return null;
    }
    private void UpdateFeatureInfo(string friendlyName)
    {
        FeatureFriendlyNameCurrent = friendlyName ;
        Console.WriteLine($"FeatureFriendlyNameCurrent: {FeatureFriendlyNameCurrent}");

        FeatureNamePipeline = currentSelectedTreeItemAICopilots.Id;
        Console.WriteLine($"FeatureNamePipeline: {FeatureNamePipeline}");

    }
}