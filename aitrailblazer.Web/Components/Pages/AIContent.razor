@page "/"
@rendermode InteractiveServer

@attribute [Authorize]

@using Markdig
@using System.Text
@using AITrailblazer.net.Services
@using AITrailblazer.net.Models

@using System.ComponentModel.DataAnnotations
@using Microsoft.AspNetCore.Authorization
@using Microsoft.Identity.Web
@using AITGraph.Sdk.Models
@using System.Diagnostics;
@using Newtonsoft.Json;
@using System.Text.RegularExpressions
@using Microsoft.AspNetCore.Components.Authorization
@using Azure.AI.OpenAI;
@using SmartComponents
@using System.ComponentModel.DataAnnotations
@using GraphMessage = AITGraph.Sdk.Models.Message

@using Microsoft.AspNetCore.Components.Web
@using VectorStoreRAG

@inject ILogger<User> Logger
@inject PluginService PluginService
@inject NavigationManager NavigationManager
@inject AITGraphService graphService
@inject IJSRuntime jsRuntime
@inject AzureOpenAIHandler azureOpenAIHandler
@inject TimeFunctions _timeFunctions
@inject UserIDsService UserIDsService
@inject RAGChatService<string> RagChatService


<IsInteractiveIndicator />
<PageTitle>@FeatureNameProject</PageTitle>

@if (currentUserIdentityID == null)
{
    <p><em>Loading...</em></p>
}
else
{
    <FluentTabs @bind-ActiveTabId="@activeid" OnTabChange="HandleOnTabChange" Class="top-tabs-font-size">
        <FluentTab Id="Workspace-id" Icon="@(new Icons.Regular.Size24.Briefcase())">
            <Header>
                Workspace
            </Header>
            <Content>

                <ChatPaneSplitter 
                    @ref="@ChatPaneSplitterRef" 
                    FeatureNameProject="@FeatureNameProject"
                    FeatureUserFriendlyName="@FeatureUserFriendlyName" 
                    FeatureDescription="@FeatureDescription" 
                    ShowLEFTPane="@showLEFTPane"
                    ShowINPUTPane="@showINPUTPane"
                    OnFeatureNameChanged="@UpdateCurrentFeatureName"
                    SelectedFile="@SelectedFile" 
                    SelectedFileContent="@SelectedFileContent" 
                    OnClearReference="ClearSelectedFileAndContent"
                    currentUserTenantID="@currentUserTenantID"
                    currentUserIdentityID="@currentUserIdentityID"
                    userEmail="@userEmail"
                    displayName="@displayName"
                    timeZoneInfo="@timeZoneInfo"
                    userTimeZone="@userTimeZone"
                    userLocalTime="@userLocalTime"
                    userLanguage="@userLanguage"

                />

            </Content>
        </FluentTab>

        <FluentTab Id="MicrosoftGraph-id" Icon="@(new Icons.Regular.Size24.Globe())">
            <Header>
                 Organizer
            </Header>
            <Content>
                <User></User>
            </Content>
        </FluentTab>

        <FluentTab Id="VectorizedDB-id" Icon="@(new Icons.Regular.Size24.BookDatabase())">
            <Header>
                Knowledge Navigator
            </Header>
            <Content>
    <FluentTabs @bind-ActiveTabId="@activeid1" OnTabChange="HandleOnTabChange1" Class="top-tabs-font-size">
        <FluentTab Id="Import-id" Icon="@(new Icons.Regular.Size24.Briefcase())">
            <Header>
                Import
            </Header>
            <Content>
                <HTMLCard FeatureNameProject="@FeatureNameImport" FeatureUserFriendlyName="@FeatureNameImportFriendlyName"
                FeatureDescription="@FeatureNameImportDescription"  FeatureDescriptionColor="black"/>

<!--
                <FluentCard MinimalStyle="true" Height="240px" Width="840px" Style="border: 1px solid var(--accent-fill-rest); padding: 20px;" Class="fluent-card-user-details-min-size ">
                        <div style="position: relative; width: 100%;">
                            <FluentStack Orientation="Orientation.Vertical" HorizontalAlignment="@Horizontal" VerticalAlignment="@Vertical"
                                VerticalGap="1" Style="border: 1px dotted var(--accent-fill-rest); position: relative; padding-right: 50px;">
                                
                                <FluentLabel Typo="Typography.Body">@fileViewName</FluentLabel>
                                @if (string.IsNullOrEmpty(fileViewName)) {
                                    <FluentTextArea Typo="Typography.Body" @bind-Value="@inputPrompt"  Placeholder="@placeholder"
                                        style="width: 100%; max-height: 200px; overflow-y: auto;" Class="card-splitter alert alert-primary content-splitter-font-size"
                                        Appearance="FluentInputAppearance.Filled" Autofocus="@Autofocus" Minlength="@MinLength"
                                        MaxLength="@MaxLength" Rows="@Rows" id="fluentTextArea" />
                                } else {
                                    <DynamicInputField FeatureName=@DBKey 
                                    Value="@userInput" ValueChanged="@((value) => { 
                                            userInput = value; 
                                            StateHasChanged(); // Ensure state is updated
                                        })" OnSubmit="@HandleInputSubmit" 
                                        Placeholder="@placeholder"
                                        Rows="10" MinLength="6" MaxLength="16384" 
                                        Autofocus="@Autofocus" Submitting="@submittingInput" />
                                }

                            </FluentStack>
                        </div>
                </FluentCard>
-->
                @if (!string.IsNullOrEmpty(HtmlContent))
                {
                    <HTMLCard FeatureNameProject="Summary" FeatureUserFriendlyName=@fileViewName
                        FeatureDescription="@HtmlContent"  FeatureDescriptionColor="green"/>
                }

                <FluentCard MinimalStyle="true" Height="100%" Width="840px" Style="border: 1px solid var(--accent-fill-rest); padding: 20px;; overflow-y: auto;" Class="fluent-card-user-details-min-size ">


                @if (submitting)
                {
                    <FluentLabel Typo="Typography.Body">Vectorizing and summarizing...</FluentLabel>

                    <FluentProgress Class="progress-upload-top" style="color: var(--themePrimary);"></FluentProgress>
                }
                <FluentInputFile Id="my-file-uploader"
                                Mode="InputFileMode.SaveToTemporaryFolder"
                                DragDropZoneVisible="true"
                                Multiple="true"
                                AnchorId="MyUploadBuffer"
                                MaximumFileCount="10"
                                MaximumFileSize="@(100*1024*1024)" 
                                
                                Accept=".pdf, .docx, .xlsx, .pptx, .jpg, .jpeg, .png, .json, .txt, .html, .md"
                                @bind-ProgressPercent="@ProgressPercent"
                                OnCompleted="@OnCompletedAsync"
                                Style="height: 300px; width: 840px; border: 1px dashed var(--accent-fill-rest);" > 
                    <ChildContent>
                        <label for="my-file-uploader">
                            <FluentIcon Value="@(new @Icons.Regular.Size24.ArrowUpload())" />
                        </label>

                        <div>
                            Drag files here you wish to upload,
                            or <label for="my-file-uploader">browse</label>
                            for them<span style="color: red;">*</span>.
                            <br />
                            <em>Maximum of 10 files allowed.</em>
                        </div>
                    </ChildContent>
                </FluentInputFile>
                <FluentProgress Visible="@(progressPercent > 0)" Min="0" Max="100" Value="@progressPercent" />
                <FluentLabel Alignment="HorizontalAlignment.Center">
                    @progressTitle
                </FluentLabel>

                <FluentButton Appearance="Appearance.Accent" Id="MyUploadBuffer">
                    Upload files
                </FluentButton>
                    @if (Files.Any())
                    {
                        <FluentCard 
                            Style="padding: 16px; max-height: 90vh; overflow-y: auto; background-color: #f7f7f7; width: 100%; max-width: 840px; margin: 0 auto;">
                            
                            <FluentText Typo="Typography.H2" Style="margin-bottom: 16px;">
                                Uploaded Files
                            </FluentText>
                            
                            <FluentList SelectionMode="ListSelectionMode.None">
                                @foreach (var file in Files)
                                {
                                    <FluentListItem Style="display: flex; align-items: center; padding: 12px 0; border-bottom: 1px solid #e1e1e1;">
                                        
                                        <!-- File Icon -->
                                        <FluentIcon 
                                            Value="@GetFileIcon(file.ContentType, file.Name)" 
                                            Size="IconSize.Size24" 
                                            Style="margin-right: 16px; color: #605e5c;" 
                                            />
                                        
                                        <!-- File Details -->
                                        <div style="flex-grow: 1;">
                                            <FluentText Typo="Typography.BodySemibold" Style="color: #323130;">
                                                @file.Name
                                            </FluentText>
                                            <FluentText Typo="Typography.Body" Style="color: #605e5c;">
                                                @($"{Decimal.Divide(file.Size, 1024):N} KB • {@file.ContentType}")
                                            </FluentText>
                                        </div>
                                        

                                    </FluentListItem>
                                }
                            </FluentList>
                        </FluentCard>
                    }
                </FluentCard>

                @if (!string.IsNullOrEmpty(ErrorMessage))
                {
                    <div style="color: red;">
                        @ErrorMessage
                    </div>
                }

            </Content>
            </FluentTab>
            <FluentTab Id="ImportedFiles-id" Icon="@(new Icons.Regular.Size24.Briefcase())">
            <Header>
                Imported Files
            </Header>
            <Content>
                <FluentCard Height="100%" Width="840px" class="folder-card">
                @if (!string.IsNullOrEmpty(ErrorMessage))
                {
                    <FluentText Typo="Typography.Body" class="error-message">
                        @ErrorMessage
                    </FluentText>
                }

                @if (SelectedFolder == null)
                {
                    @if (SelectedFile?.FileName != null)
                    {
                        <FluentText Typo="Typography.Body" Style="margin-bottom: 8px;">
                            Reference: <b>@SelectedFile.FileName</b>
                        </FluentText>
                    }
                    <FluentList style="display: flex; flex-direction: column; max-height: 400px; overflow-y: auto;">
                        @foreach (var folder in Folders)
                        {
                            <FluentListItem style="display: flex; align-items: center; justify-content: space-between; padding: 8px 0;">
                        <div style="display: flex; align-items: center;">
                                <FluentButton 
                                    Appearance="Appearance.Stealth" 
                                    class="folder-button"
                                    @onclick="() => LoadFilesInFolder(folder)"
                                    >
                                    
                                    <!-- Folder Icon -->
                                    <FluentIcon 
                                        Value="@(new Icons.Regular.Size24.Folder())" 
                                        Size="IconSize.Size24" 
                                        class="folder-icon" 
                                         />
                                    
                                    <!-- Folder Name -->
                                    <FluentText Typo="Typography.BodySemibold" class="folder-name">
                                        @folder
                                    </FluentText>
                                </FluentButton>
                        </div>
                            </FluentListItem>
                        }
                    </FluentList>
                }
                else
                {
                    <div style="display: flex; align-items: center; margin-bottom: 16px;">
                        <FluentButton 
                            Appearance="Appearance.Stealth" 
                            IconStart="@(new Icons.Regular.Size20.ArrowStepBack())" 
                            @onclick="GoBackToFolders"
                            
                            Style="margin-right: 12px;">
                        </FluentButton>
                        
                        <FluentText Typo="Typography.H4" Style="color: #323130;">
                            @SelectedFolder
                        </FluentText>
                    </div>
                    
                    @if (DisplayedFiles.Any())
                    {
                        <FluentDataGrid Items="@DisplayedFiles.AsQueryable()" ShowHover="true" TGridItem="FileItemRow">
                            <!-- Select Column for single selection -->
                            <SelectColumn TGridItem="FileItemRow" SelectMode="DataGridSelectMode.Single"
                                        SelectedItemsChanged="OnSelectedFileChanged" />

                            <!-- File Name Column with sorting -->
                            <PropertyColumn Property="@(f => f.FileName ?? "No Name")" Title="File Name" Sortable="true" />

                            <!-- Size (KB) Column with sorting -->
                            <PropertyColumn Property="@(f => f.SizeInKB)" Title="Size (KB)" Sortable="true" />
                        </FluentDataGrid>



                    }
                    else
                    {
                        <FluentText Typo="Typography.Body" Style="color: #605e5c;">
                            No files available in this folder.
                        </FluentText>
                    }
                }

                </FluentCard>
                        <!-- Display file content dialog or other actions -->
                        @if (IsFileContentDialogOpen)
                        {
                            <FluentDialog @bind-Visible="IsFileContentDialogOpen">
                            <FluentCard MinimalStyle="true" Width="400px" Style="border: 1px solid var(--accent-fill-rest); padding: 0px;">

                                <FluentDialogHeader>
                                    <h2>@SelectedFile?.FileName</h2>
                                </FluentDialogHeader>
                                <FluentDialogBody>
                                    @if (!string.IsNullOrEmpty(SelectedFileContent))
                                    {
                                        <FluentLabel Typo="Typography.Body" Class="content-splitter-font-size" 
                                            style="width: 100%; height: 400px; overflow-y: auto;">
                                            @((MarkupString)Markdown.ToHtml(SelectedFileContent))
                                        </FluentLabel>
                                    }
                                    else
                                    {
                                        <p>No content available or file is empty.</p>
                                    }
                                </FluentDialogBody>
                                <FluentDialogFooter>
                                    <FluentButton @onclick="() => IsFileContentDialogOpen = false">Close</FluentButton>
                                </FluentDialogFooter>
                            </FluentCard>
                            </FluentDialog>
                        }

                        @if (!string.IsNullOrEmpty(ErrorMessage))
                        {
                            <div class="error-message">@ErrorMessage</div>
                        }
            </Content>
            </FluentTab>        
    </FluentTabs>
  
            </Content>
        </FluentTab>

        <FluentTab Id="Help-id" Icon="@(new Icons.Regular.Size24.QuestionCircle())">
            <Header>
                Help
            </Header>
            <Content>
                <FluentTabs>
                    <FluentTab Id="Description-id">
                        <Header>
                            Description
                        </Header>
                        <Content>
                            @if (!isMarkdownDescriptionLoaded)
                            {
                                <p><em>Loading description content...</em></p>
                            }
                            else
                            {
                                <FluentCard MinimalStyle="true" Height="auto" Width="840px" Style="border: 1px solid var(--accent-fill-rest); overflow-y: auto; padding: 40px; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
                                    <FluentMarkdownRenderer MarkdownContent="@markdownContentDescription" />
                                </FluentCard>
                            }
                        </Content>
                    </FluentTab>

                    <FluentTab Id="Wizard-id">
                        <Header>
                            Step by step
                        </Header>
                        <Content>
                            @if (!isMarkdownHelpLoaded)
                            {
                                <p><em>Loading help content...</em></p>
                            }
                            else
                            {
                                <MarkdownWizard MarkdownContent="@markdownContentHelpStepByStep" />
                            }
                        </Content>
                    </FluentTab>
                </FluentTabs>
            </Content>
        </FluentTab>
    </FluentTabs>
}
<FluentToastProvider />
<FluentDialogProvider />
<FluentTooltipProvider />
<FluentMessageBarProvider />
<FluentMenuProvider />
@code {
    private string DBKey = null;
    public bool showLEFTPane { get; set; } = true;
    public bool showINPUTPane { get; set; } = true;
    private string FeatureNameImportDescription = "Streamline your workflow effortlessly with our seamless file import feature! Import files up to 512KB with ease. If a file with the same name exists, it will be automatically replaced, ensuring your data stays organized. Upload once, and enjoy unlimited access to perform questions and summaries as many times as you like. Supported formats include .json, .txt, .html, .md, .pdf. Start optimizing your workflow today!";

    private string FeatureNameProject = "AIContent";
    private string FeatureName = "";
    private string FeatureName1 = "";
    private string FeatureName2 = "";
    private string FeatureName3 = "";
    public string CurrentFeatureName { get; set; } = "AIWritingAssistant";
    private string FeatureUserFriendlyName = "Content";
    private string FeatureDescription = "Create unique content tailored to specific topics, styles, and audience understanding levels.";
    private string currentUserTenantID;
    private string currentUserIdentityID;
    private Profile profile;
    private UserAccountInformation accountInfo;
    private string? displayName;
    private string userEmail = "konstantine@aitrailblazer.com";
    private string userFullName;
    private string userPhoneNumer;
    private string userLanguage;
    private string userAddress;
    private string? Tenant;
    private string userPrincipalJson = "default-principal";
    private ChatPaneSplitter? ChatPaneSplitterRef;
    private bool isLoading = true;
    private bool isMessagesLoading = false;
    private bool isAIOrganizerLoading = false;    private bool isSearch = false;

    FluentInputFileEventArgs[] Files = Array.Empty<FluentInputFileEventArgs>();

    private string FeatureNameImport = "Import";
    private string FeatureNameImportFriendlyName = "File import";
    private string HtmlContent { get; set; }
    public int MinLength { get; set; } = 16;
    public int MaxLength { get; set; } = 1024;
    public int Rows { get; set; } = 24;

    string? fileViewName = null;
    string userInput = "";
    string inputPrompt = "";
    string placeholder = "";
    private Stopwatch _timer;

    private string pluginPath;
    private string markdownContentDescription;
    private string markdownContentHelpStepByStep;
    public bool Autofocus { get; set; } = true;

    private bool isInitialized = false;

    private string timeZoneInfo;

    private string userTimeZone;
    private DateTime userLocalTime;

    private bool isMicrosoftGraphLoaded = false;
    private bool isMarkdownDescriptionLoaded = false;
    private bool isMarkdownHelpLoaded = false;

    private IEnumerable<EmailViewModel> emails;
    string? activeid = "Workspace-id";
    string currenttab = "Workspace-id";
    string? activeid1 = "Import-id";

    private string error;

    private string? userPhotoBase64;
    private List<GraphMessage> userMessages = new List<GraphMessage>();
    //private IEnumerable<Microsoft.Graph.Models.DriveItem> driveItems = Enumerable.Empty<Microsoft.Graph.Models.DriveItem>();
    
    private CalendarEventsResult calendarEventsResult = new CalendarEventsResult();
    private List<Event> calendarViewEventsResult;
    private List<EventViewModel> calendarEventsWithComputedProperties = new List<EventViewModel>();
 
    //private IEnumerable<Microsoft.Graph.Models.Contact>? contacts = Enumerable.Empty<Microsoft.Graph.Models.Contact>();
    private List<PureEmailViewBasicModel> emailsWithComputedProperties = new List<PureEmailViewBasicModel>();
    private List<ContactViewModel> contactsWithComputedProperties = new List<ContactViewModel>();
    private ContactViewModel selectedContact;
    private ContactViewModel originalContact = new ContactViewModel(new Contact());

    
    private PaginationState pagination = new PaginationState { ItemsPerPage = 10 };

    protected override async Task OnInitializedAsync()
    {
        if (!isInitialized)
        {
            await LoadUserDataAsync();
            isInitialized = true;
        }
    }
    private async Task LoadUserDataAsync()
    {
        isLoading = true;  // Show loading state
        error = null;
        emailsWithComputedProperties.Clear();  // Clear previous data

        try
        {
     
            // Trigger re-render to show the result
            profile = await graphService.GetCurrentUserProfileAsync();
            accountInfo = await graphService.GetUserAccountInformationAsync();
            
            var (userId, tenantId) = await UserIDsService.GetUserIDsAsync();
            currentUserIdentityID = userId;
            currentUserTenantID = tenantId;
            
            userTimeZone = await UserIDsService.GetTimeZoneAsync();
            //Console.WriteLine($"LoadUserDataAsync userTimeZone: {userTimeZone}");

            timeZoneInfo = _timeFunctions.GetUserTimeZone();
            //Console.WriteLine($"LoadUserDataAsync timeZoneInfo: {timeZoneInfo}");
            
            // Get the current UTC time
            DateTime utcNow = DateTime.UtcNow;

            // Convert to user's local time
            userLocalTime = await UserIDsService.ConvertToUserTimeZoneAsync(utcNow);
            
            userLanguage = GetUserLanguage();

            userEmail = GetUserEmail();
            userFullName = GetUserFullName();  
            //displayName = userFullName;

            //userPhoneNumer = GetUserPhoneNumber();

            //userLanguage = GetUserLanguage();

            //userAddress = GetUserAddress();

            
            // Fetch the user's profile photo
            var photoStream = await graphService.GetUserPhotoAsync();
            if (photoStream != null)
            {
                using (var memoryStream = new MemoryStream())
                {
                    await photoStream.CopyToAsync(memoryStream);
                    userPhotoBase64 = Convert.ToBase64String(memoryStream.ToArray());
                }
            }

  
            var mailboxSettings = await graphService.GetMailboxSettingsAsync();
            if (mailboxSettings != null)
            {
                //($"Time Zone: {mailboxSettings.TimeZone}");
                //Console.WriteLine($"Date Format: {mailboxSettings.DateFormat}");
                //Console.WriteLine($"Time Format: {mailboxSettings.TimeFormat}");
                
                // Accessing other properties
                //Console.WriteLine($"Archive Folder: {mailboxSettings.ArchiveFolder}");
                
                if (mailboxSettings.AutomaticRepliesSetting != null)
                {
                    //Console.WriteLine($"Automatic Replies Status: {mailboxSettings.AutomaticRepliesSetting.Status}");
                    //Console.WriteLine($"External Audience: {mailboxSettings.AutomaticRepliesSetting.ExternalAudience}");
                    // Add more properties as needed
                }
                
                if (mailboxSettings.Language != null)
                {
                    //Console.WriteLine($"Language Locale: {mailboxSettings.Language.Locale}");
                    //Console.WriteLine($"Language Display Name: {mailboxSettings.Language.DisplayName}");
                }
                
                if (mailboxSettings.WorkingHours != null)
                {
                    //Console.WriteLine($"Working Hours Start Time: {mailboxSettings.WorkingHours.StartTime}");
                    //Console.WriteLine($"Working Hours End Time: {mailboxSettings.WorkingHours.EndTime}");
                    //Console.WriteLine($"Working Days: {string.Join(", ", mailboxSettings.WorkingHours.DaysOfWeek)}");
                }
                
                //Console.WriteLine($"User Purpose: {mailboxSettings.UserPurpose}");
                //Console.WriteLine($"User Purpose V2: {mailboxSettings.UserPurposeV2}");
                //Console.WriteLine($"Delegate Meeting Message Delivery Options: {mailboxSettings.DelegateMeetingMessageDeliveryOptions}");
            }
        }
        catch (AuthenticationRequiredException)
        {
            RedirectToLogin();
        }
        catch (Exception ex)
        {
            error = $"Error loading user data: {ex.Message}";
        }
        finally
        {
            isLoading = false;  // Hide loading state
        }
    }

    private DateTime GetStartOfWeek(DateTime date)
    {
        // Assuming week starts on Monday
        int diff = (7 + (date.DayOfWeek - DayOfWeek.Monday)) % 7;
        return date.AddDays(-1 * diff).Date;
    }

    private int currentPage = 1;
    private const int PageSize = 10;  // Load 10 messages per page

 
    private async Task HandleOnTabChange(FluentTab tab)
    {
        currenttab = tab.Id;
        //Console.WriteLine($"Tab changed to {tab.Id}");

        if (tab.Id == "MicrosoftGraph-id" && !isMicrosoftGraphLoaded)
        {
            //await LoadMicrosoftGraphData();
        }
        //currenttab = tab.Id;
        //Console.WriteLine($"AIContent HandleOnTabChange Tab changed to {tab.Id}");
        if (tab.Id == "Workspace-id")
        {
            if (!string.IsNullOrEmpty(SelectedFileContent))
            {
                ChatPaneSplitterRef?.TriggerParseOntologyTree(SelectedFileContent);
                //Console.WriteLine($"HandleOnTabChange called ParseOntologyTreeMarkdown with content: {SelectedFileContent}");
            }
            else
            {
                //Console.WriteLine("SelectedFileContent is null or empty");
            }
        }
        if (tab.Id == "Help-id")
        {
            if (!isMarkdownDescriptionLoaded)
            {
                await LoadMarkdownDescriptionContent();
            }

            if (!isMarkdownHelpLoaded)
            {
                await LoadMarkdownHelpContent();
            }
        }
    }
    private async Task HandleOnTabChange1(FluentTab tab)
    {

    }
    private void RedirectToLogin()
    {
        var uri = NavigationManager.ToAbsoluteUri(NavigationManager.Uri);
        var queryString = System.Web.HttpUtility.ParseQueryString(uri.Query);
        // Get the value of the "myParameter" query string parameter
        Tenant = queryString["Tenant"];
        //Console.WriteLine($"Tenant: {Tenant}");
   
        // Log the returnUrl for debugging purposes
        //Console.WriteLine($"uri: {uri}");

        // Navigate to the sign-in page with the encoded returnUrl
        NavigationManager.NavigateTo($"/MicrosoftIdentity/Account/SignIn?returnUrl={uri}", forceLoad: true);
    }

     // @using OurNewsArticle = AITrailblazer.net.Models.NewsArticle

    // Event handler for handling input changes (optional)
    private void HandleInput(ChangeEventArgs e)
    {
        // Optional: Handle input changes if needed
        // Currently, @bind-Value takes care of updating userQuery
    }
    // List to hold the news articles
    //private List<OurNewsArticle> newsArticles = new List<OurNewsArticle>();

    private async Task LoadMarkdownDescriptionContent()
    {
        try
        {
            var basePluginPath = PluginService.GetPluginsPath();
            var descriptionFilePath = Path.Combine(basePluginPath, $"{CurrentFeatureName}_Description.md");

            if (File.Exists(descriptionFilePath))
            {
                markdownContentDescription = await File.ReadAllTextAsync(descriptionFilePath);
            }

            isMarkdownDescriptionLoaded = true;
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading markdown description content.");
            markdownContentDescription = "Error loading description content.";
        }
    }

    private async Task LoadMarkdownHelpContent()
    {
        try
        {
            var basePluginPath = PluginService.GetPluginsPath();
            var helpFilePath = Path.Combine(basePluginPath, $"{CurrentFeatureName}_Help_StepByStep.md");

            if (File.Exists(helpFilePath))
            {
                markdownContentHelpStepByStep = await File.ReadAllTextAsync(helpFilePath);
            }

            isMarkdownHelpLoaded = true;
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading help content.");
            markdownContentHelpStepByStep = "Error loading Help StepByStep content.";
        }
    }

    public async Task UpdateCurrentFeatureName(string newFeatureName)
    {
        CurrentFeatureName = newFeatureName;
        await LoadMarkdownDescriptionContent();
        await LoadMarkdownHelpContent();
    }
}
@code {
    string[] projects =
    [
        "Sales intranet",
        "Customer portal",
        "Mobile app",
        "Mobile app (v2 beta)",
        "PowerEye Security",
    ];

    Component[] components =
    [
        new("backup", "Backup/restore"),
        new("ui", "User interface"),
        new("webhooks", "Web hooks"),
        new("llm", "Language models"),
        new("offline", "Offline support"),
        new("windows", "Windows"),
        new("mac", "Mac"),
        new("linux", "Linux"),
        new("build", "Build system"),
        new("perf", "Performance"),
        new("security", "Security"),
    ];

    record Component(string Id, string Name);
}

@code {

        private Dictionary<string, List<FileItemRow>> FolderFiles = new();
        private List<string> Folders = new();
        private List<FileItemRow> DisplayedFiles = new();
        private string SelectedFolder = null;
        private string ErrorMessage = string.Empty;

        // Variables for File Content Display
        private FileItemRow SelectedFile = null;
        private string SelectedFileContent = string.Empty;
        private void ClearSelectedFileAndContent()
        {
            SelectedFile = null;
            SelectedFileContent = string.Empty;
            //Console.WriteLine("SelectedFile and SelectedFileContent cleared in AIContent.razor");
        }

        private bool IsFileContentDialogOpen = false;
        private async Task LoadUploadedFilesAsync()
        {
            try
            {
                var manager = azureOpenAIHandler.BlobStorageManagerCreate();
                string directory = FeatureNameProject + "FileInput";
                string tenantId = currentUserTenantID;
                string userId = currentUserIdentityID;

                string destination = $"{tenantId}-{userId}-{directory}/";

                var blobs = await manager.ListBlobsAsync(destination);

                // Group by folder and collect files
                FolderFiles = blobs
                    .Where(blob => !blob.Name.EndsWith("/Input")) // Exclude 'Input' blobs
                    .Select(blob =>
                    {
                        // Strip out the destination prefix
                        string relativePath = blob.Name.Replace(destination, "");

                        // Split the remaining path into folder and file parts
                        var parts = relativePath.Split('/');
                        string folder = parts.Length > 1 ? parts[0] : "Default";
                        string fileName = parts.Last();

                        return new FileItemRow
                        {
                            Folder = folder,
                            FileName = fileName,
                            SizeInKB = blob.Properties.ContentLength.HasValue
                                ? (long)(blob.Properties.ContentLength.Value / 1024.0)
                                : 0,
                        };
                    })
                    .GroupBy(f => f.Folder)
                    .ToDictionary(g => g.Key, g => g.ToList());

                // Populate Folders for the initial view
                Folders = FolderFiles.Keys.ToList();
                //Console.WriteLine($"Loaded {Folders.Count} folders.");
            }
            catch (Exception ex)
            {
                ErrorMessage = $"Error loading files: {ex.Message}";
            }
        }

    private void LoadFilesInFolder(string folder)
    {
        // Set the selected folder and load the files in that folder
        SelectedFolder = folder;
        //Console.WriteLine($"Selected Folder: {SelectedFolder}");

        if (FolderFiles.TryGetValue(folder, out var files))
        {
            DisplayedFiles = files;
            //Console.WriteLine($"Loaded {files.Count} files in folder '{folder}'.");
        }
        else
        {
            // Handle the case where the folder is not found
            DisplayedFiles = new List<FileItemRow>();
            //Console.Error.WriteLine($"Folder '{folder}' not found in FolderFiles.");
        }

        // Force UI to re-render
        StateHasChanged();
    }

    private void GoBackToFolders()
    {
        // Reset the view to show folders again
        SelectedFolder = null;
        DisplayedFiles = new List<FileItemRow>();
        //Console.WriteLine("Navigated back to Folders view.");

        // Force UI to re-render
        StateHasChanged();
    }
    private async Task OpenFileContentAsync(FileItemRow file)
    {
        try
        {
            SelectedFile = file;
            // AITrailblazer_AIAssistantSettings.md

            // Opening file content for AITrailblazer...
            //Console.WriteLine($"OpenFileContentAsync Opening file content for {SelectedFolder}...");
            // Selected file: AITrailblazer_AIAssistantSettings.md
            //Console.WriteLine($"OpenFileContentAsync Selected file: {SelectedFile.FileName}");
            // Attempting to read blob at path: 
            // 8f22704e-0396-4263-84a7-63310d3f39e7-AIContentFileInput/AITrailblazer/AITrailblazer_AIAssistantSettings.md
            // 8f22704e-0396-4263-84a7-63310d3f39e7-AIContentFileInput/AITrailblazer/AITrailblazer_AIAssistantSettings.md/AITrailblazer_AIAssistantSettings.md
            
            string tenantId = currentUserTenantID;
            string userId = currentUserIdentityID;

            SelectedFileContent = await azureOpenAIHandler.ReadBlobContentAsync(
                tenantId,
                userId,
                FeatureNameProject + "FileInput",
                SelectedFolder,
                SelectedFile.FileName + "/" + SelectedFile.FileName
            );
            //Console.WriteLine($"OpenFileContentAsync SelectedFileContent: {SelectedFileContent}");

            if (string.IsNullOrEmpty(SelectedFileContent))
            {
                ErrorMessage = "File content is empty or could not be retrieved.";
            }
            else
            {
                ErrorMessage = string.Empty;

                IsFileContentDialogOpen = true;
                StateHasChanged();  // Force UI re-render
                //Console.WriteLine($"OpenFileContentAsync IsFileContentDialogOpen: {IsFileContentDialogOpen}");
            }

        }
        catch (Exception ex)
        {
            ErrorMessage = $"Error loading file content: {ex.Message}";
            Console.Error.WriteLine(ErrorMessage);
            IsFileContentDialogOpen = false;
            StateHasChanged();  // Force UI re-render
            //Console.WriteLine($"OpenFileContentAsync Error loading file content IsFileContentDialogOpen: {IsFileContentDialogOpen}");
        }
    }
    private void OnSelectedFileChanged(IEnumerable<FileItemRow> selectedFiles)
    {
        var selectedFile = selectedFiles.FirstOrDefault();
        if (selectedFile != null)
        {
            SelectedFile = selectedFile;
            //Console.WriteLine($"OnSelectedFileChanged Selected file: {selectedFile.FileName}");
            // AITrailblazer_AIAssistantSettings.md
            OpenFileContentAsync(selectedFile);
        }
    }

    private void CloseFileContentDialog()
    {
        IsFileContentDialogOpen = false;
        SelectedFile = null;
        SelectedFileContent = string.Empty;
        ErrorMessage = string.Empty;
    }
    private void DownloadFile(FileItemRow file)
    {
        // TODO: Implement actual download logic
        //Console.WriteLine($"Downloading {file.FileName}...");
    }
    private void DeleteFile(FileItemRow file)
    {
        // TODO: Implement actual deletion logic
        //Console.WriteLine($"Deleting {file.FileName}...");
        //DisplayedFiles.Remove(file);

        // Optionally, update FolderFiles if necessary
        //if (FolderFiles.ContainsKey(file.Folder))
        //{
            //FolderFiles[file.Folder].Remove(file);
        //    Console.WriteLine($"Removed {file.FileName} from FolderFiles[{file.Folder}].");
        //}

        // Force UI to re-render
        //StateHasChanged();
    }
}

@code {
    public class CustomFileItem
    {
        public string Name { get; set; }
        public long Size { get; set; }
        public string ContentType { get; set; }
    }

    private async Task<string> HandleInputSubmit()
    {
        this._timer = new Stopwatch();
        this._timer.Restart();

        if (userInput.Trim() != "")
        {
            submittingInput = true;
            //Console.WriteLine($"HandleInputSubmit userInput {userInput}");
            string tenantId = currentUserTenantID;
            string userId   = currentUserIdentityID;

            var manager = azureOpenAIHandler.BlobStorageManagerCreate();
            string fileName = fileViewName;

            string directory = FeatureNameProject+"FileInput"; // Directory structure in which the blob will be stored
            string currentTime = DateTime.UtcNow.ToString("yyyyMMdd-HHmmss");
            string blobName = $"ChatThread-{fileName}-{currentTime}"; // Name of the blob to be created            string contentName = "Input"; // Name of the content to be stored in the blob

            
            string contentName = "Input"; // Name of the content to be stored in the blob
            string content = userInput;
            var jsonParameters = new
            {
                Input = input,
            };
            string jsonContent = JsonConvert.SerializeObject(jsonParameters, Formatting.Indented);

            // Call the UploadStringToBlobAsync method
            await manager.UploadStringToBlobAsync(
                tenantId, 
                userId,
                directory, 
                blobName, 
                contentName,
                content);

            string PanelInput = "";
            //string input;
            string masterTextSetting = "Content";
            string responseLengthVal = "8192";
            string creativeAdjustmentsVal = "Analytical";
            string audienceLevelVal = "";
            string writingStyleVal = "";
            string relationSettingsVal = "";
            string responseStyleVal = "";

            // should be empty to use the caching directly
            string encodedData = "";

            string Feature ="AIImportFilesQuery";
            this._timer.Stop();
            //Console.WriteLine($"Time: {this._timer.ElapsedMilliseconds / 1000} secs");

        }
        return "";
    }
    private async Task OnCompletedAsync(IEnumerable<FluentInputFileEventArgs> files)
    {

        this._timer = new Stopwatch();
        this._timer.Restart();
           
        string tenantId = currentUserTenantID;
        string userId = currentUserIdentityID;
        
        fileViewName = null;
        Files = files.ToArray();
        //Console.WriteLine($"OnCompletedAsync: {Files.Length} files uploaded."); 

        Console.WriteLine($"OnCompletedAsync start..."); 
        // Clear any previous error messages
        ErrorMessage = string.Empty;
        MarkdownContentFile = string.Empty;
        <!-- ".pdf", ".docx", ".xlsx", ".pptx", ".jpg", ".jpeg", ".png" -->
        var allowedExtensions = new HashSet<string>
        {
            ".pdf", ".docx", ".xlsx", ".pptx", ".jpg", ".jpeg", ".png", ".json", ".txt", ".html", ".md"
        };
        var imageExtensions = new HashSet<string>
        {
            ".pdf", ".docx", ".xlsx", ".pptx", 
            ".jpg", ".jpeg", ".png"
        };
        foreach (var file in Files)
        {
            // Get the file extension
            var fileExtension = Path.GetExtension(file.Name).ToLowerInvariant();

            // Validate file extension
            if (!allowedExtensions.Contains(fileExtension))
            {
                ErrorMessage = "Invalid file type. Only .pdf, .docx, .xlsx, .pptx, .jpg, .jpeg, .png, .json, .txt, .html, .md files are allowed.";
                continue;
            }
            //try
            //{
                var filePath = file.LocalFile?.FullName;
                
                if (filePath != null)
                {
                    submitting = true; 
                    //Console.WriteLine($"fileContent: {fileContent}");
                    //Console.WriteLine($"file.Name: {file.Name}");

                    if (allowedExtensions.Contains(fileExtension))
                    {
                        try
                            {
                                Console.WriteLine($"Processing file: {filePath}");
                                
                                // Open the file as a stream and pass it to the data loader
                                using FileStream fileStream = new FileStream(
                                    filePath,
                                    FileMode.Open,
                                    FileAccess.Read,
                                    FileShare.Read,
                                    bufferSize:  524288  // 512 KB buffer
                                );    
                                // Set the stream position to the beginning
                                fileStream.Position = 0;                            
                                string fileName = file.Name;
                                
                                var manager = azureOpenAIHandler.BlobStorageManagerCreate();
                                // Extract subdirectory from filename
                                //string[] parts = file.Name.Split('_');
                                string directory = "Documents";//FeatureNameProject+"FileInput"; // Directory structure in which the blob will be stored
                                string subdirectory = "Default";//parts.Length > 1 ? parts[0] : "Default";

                                string blobName = subdirectory;//$"{subdirectory}/{file.Name}";

                                fileName = azureOpenAIHandler.CreateValidFilename(fileName);

                                // Upload the file stream to Azure Blob Storage
                                await manager.UploadBlobFromStreamAsync(
                                    tenantId, 
                                    userId,
                                    directory, 
                                    blobName,
                                    fileName, 
                                    fileStream);

                                //string destination = $"{tenantId}/{userId}/{directory}/{blobName}/{fileName}";
                                //string filePathDestination = destination;
                                // Directly process the file using its path
                                fileStream.Position = 0;                            

                                MarkdownContentFile = await HandleInputFileFromStream(
                                    tenantId,
                                    userId,
                                    directory,
                                    blobName,
                                    fileStream,
                                    fileName,
                                    fileExtension,
                                    tags);

                                // Format the content with new lines after each line
                                if (!string.IsNullOrEmpty(MarkdownContentFile))
                                {
                                    MarkdownContentFile = AddNewLinesAfterEveryLine(MarkdownContentFile);
                                }
                                

                                Console.WriteLine($"File processed successfully: {file.Name}");
                            }
                            catch (Exception ex)
                            {
                                Console.WriteLine($"Error processing file {file.Name}: {ex.Message}");
                                ErrorMessage = $"Failed to process the file: {file.Name}. Error: {ex.Message}";
                            }
                    }
                    //Console.WriteLine($"MarkdownContentFile: {MarkdownContentFile}");
                    // Convert Markdown to HTML
                    //HtmlContent = Markdown.ToHtml(MarkdownContentFile);

                    tags = "";

                    //Console.WriteLine($"HtmlContent: {HtmlContent}");
                    submitting = false;
                }
            //}
            //catch (Exception ex)
            //{
            //    ErrorMessage = $"Error reading file: {ex.Message}";
            //}        
        }
        /*
        async Task<string> HandleInputFileFromPath(
            string tenantID,
            string userID, 
            string indexName, 
            string filePath, 
            string fileName, 
            string fileExtension, 
            string tags)
        {
            this._timer = new Stopwatch();
            this._timer.Restart();

            Console.WriteLine($"HandleInputFileFromPath index: {indexName}");

            // Generate a memoryKey based on tenantID, userID, and fileName
            fileName = azureOpenAIHandler.CreateValidFilename(fileName);
            var memoryKey = $"{tenantID}-{userID}-{fileName}";
            Console.WriteLine($"HandleInputFileFromPath memoryKey: {memoryKey}");

            try
            {
                // Call ProcessPdfAsync directly
                Console.WriteLine($"Calling ProcessPdfAsync for {filePath}");
                await RagChatService.ProcessPdfAsync(
                    filePath, 
                    tenantID, 
                    userID, 
                    CancellationToken.None);

                Console.WriteLine("ProcessPdfAsync completed successfully");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error in HandleInputFileFromPath: {ex}");
                throw;
            }
            finally
            {
                this._timer.Stop();
                Console.WriteLine($"HandleInputFileFromPath completed in {this._timer.ElapsedMilliseconds / 1000} seconds");
            }

            return $"Successfully processed file: {fileName}";
        }
        */
        async Task<string> HandleInputFileFromStream(
            string tenantID,
            string userID, 
            string directory,
            string blobName,
            Stream fileStream,
            string fileName, 
            string fileExtension, 
            string tags)
        {
            this._timer = new Stopwatch();
            this._timer.Restart();

            // Generate a memoryKey based on tenantID, userID, and fileName
            //fileName = azureOpenAIHandler.CreateValidFilename(fileName);
            var memoryKey = $"{tenantID}-{userID}-{fileName}";
            Console.WriteLine($"HandleInputFileFromStream memoryKey: {memoryKey}");

            try
            {
                // Call ProcessPdfAsync directly
                Console.WriteLine($"Calling HandleInputFileFromStream for {fileName}");
                await RagChatService.ProcessPdfStreamAsync(
                    tenantID, 
                    userID, 
                    fileName,                    
                    directory, 
                    blobName,
                    memoryKey,
                    fileStream,
                    CancellationToken.None);

                Console.WriteLine("ProcessPdfStreamAsync completed successfully");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error in HandleInputFileFromStream: {ex}");
                throw;
            }
            finally
            {
                this._timer.Stop();
                Console.WriteLine($"HandleInputFileFromStream completed in {this._timer.ElapsedMilliseconds / 1000} seconds");
            }

            return $"Successfully processed file: {fileName}";
        }

        bool IsBase64String(string s)
        {
            s = s.Trim();
            return (s.Length % 4 == 0) && Regex.IsMatch(s, @"^[a-zA-Z0-9\+/]*={0,3}$", RegexOptions.None);
        }
         string EncodeToBase64(string data)
        {
            // Convert the string to bytes
            var bytes = Encoding.UTF8.GetBytes(data);
            // Convert bytes to Base64 string
            return Convert.ToBase64String(bytes);
        }
        string AddNewLinesAfterEveryLine(string markdownContentDescription)
        {
            // Split the content into lines
            var lines = markdownContentDescription.Split(new[] { "\r\n", "\r", "\n" }, StringSplitOptions.None);
            
            // Use StringBuilder for efficient string manipulation
            var stringBuilder = new StringBuilder();
            
            foreach (var line in lines)
            {
                // Append the line and add a newline after each line
                stringBuilder.AppendLine(line);
                stringBuilder.AppendLine(); // Adds an extra newline
            }
            
            // Convert the StringBuilder to a string and return it
            return stringBuilder.ToString();
        }
    }


}

@code
{
    int ProgressPercent = 0;
     int? progressPercent;
    string? progressTitle="Upload Progress";
    private string MarkdownContentFile="";

    string? input = "";

    string? tags = "";
 
    private bool submitting = false;

    private bool submittingInput = false;
    HorizontalAlignment Horizontal;
    VerticalAlignment Vertical;
    string? indexName = "";

}


@code {
    // Dictionary for file extension to icon mapping
    private readonly Dictionary<string, Func<Icon>> extensionIconMap = new Dictionary<string, Func<Icon>>
    {
        { ".jpg", () => new Icons.Regular.Size24.Image() },
        { ".jpeg", () => new Icons.Regular.Size24.Image() },
        { ".png", () => new Icons.Regular.Size24.Image() },
        { ".gif", () => new Icons.Regular.Size24.Image() },
        { ".bmp", () => new Icons.Regular.Size24.Image() },
        { ".svg", () => new Icons.Regular.Size24.Image() },
        { ".pdf", () => new Icons.Regular.Size24.DocumentPdf() },
        { ".doc", () => new Icons.Regular.Size24.Document() },
        { ".docx", () => new Icons.Regular.Size24.Document() },
        { ".txt", () => new Icons.Regular.Size24.Document() },
        { ".xls", () => new Icons.Regular.Size24.DocumentData() },
        { ".xlsx", () => new Icons.Regular.Size24.DocumentData() },
        { ".ppt", () => new Icons.Regular.Size24.DocumentData() },
        { ".pptx", () => new Icons.Regular.Size24.DocumentData() },
        { ".mp4", () => new Icons.Regular.Size24.Video() },
        { ".avi", () => new Icons.Regular.Size24.Video() },
        { ".mov", () => new Icons.Regular.Size24.Video() },
        { ".mp3", () => new Icons.Regular.Size24.Document() }, // Fallback as "Audio" icon is unavailable
        { ".wav", () => new Icons.Regular.Size24.Document() }, // Fallback as "Audio" icon is unavailable
        { ".zip", () => new Icons.Regular.Size24.FolderZip() },
        { ".rar", () => new Icons.Regular.Size24.FolderZip() },
        { ".7z", () => new Icons.Regular.Size24.FolderZip() },
        { ".json", () => new Icons.Regular.Size24.DocumentData() },
        { ".xml", () => new Icons.Regular.Size24.DocumentData() },
        { ".js", () => new Icons.Regular.Size24.Javascript() },
        { ".css", () => new Icons.Regular.Size24.DocumentCss() },
        // Add more file extension mappings as needed
    };

    // Dictionary for content type to icon mapping
    private readonly Dictionary<string, Func<Icon>> contentTypeIconMap = new Dictionary<string, Func<Icon>>
    {
        { "image/", () => new Icons.Regular.Size24.Image() },
        { "application/pdf", () => new Icons.Regular.Size24.DocumentPdf() },
        { "application/javascript", () => new Icons.Regular.Size24.Javascript() },
        { "text/javascript", () => new Icons.Regular.Size24.Javascript() },
        { "application/x-javascript", () => new Icons.Regular.Size24.Javascript() },
        { "text/css", () => new Icons.Regular.Size24.DocumentCss() },
        { "video/", () => new Icons.Regular.Size24.Video() },
        { "application/zip", () => new Icons.Regular.Size24.FolderZip() },
        { "application/x-rar-compressed", () => new Icons.Regular.Size24.FolderZip() },
        { "application/x-7z-compressed", () => new Icons.Regular.Size24.FolderZip() },
        { "application/vnd", () => new Icons.Regular.Size24.DocumentData() }, // For various Microsoft Office formats
        // Add more content type mappings as needed
    };

    private Icon GetFileIcon(string contentType, string fileName)
    {
        // Check if contentType is available and map accordingly
        if (!string.IsNullOrWhiteSpace(contentType))
        {
            foreach (var kvp in contentTypeIconMap)
            {
                if (kvp.Key.EndsWith("/")) // For wildcard types like image/*
                {
                    if (contentType.StartsWith(kvp.Key, StringComparison.OrdinalIgnoreCase))
                    {
                        return kvp.Value();
                    }
                }
                else
                {
                    if (string.Equals(contentType, kvp.Key, StringComparison.OrdinalIgnoreCase))
                    {
                        return kvp.Value();
                    }
                }
            }
        }

        // Fallback to file extension if contentType mapping is not found
        if (!string.IsNullOrWhiteSpace(fileName))
        {
            var extension = Path.GetExtension(fileName).ToLowerInvariant();
            if (extensionIconMap.TryGetValue(extension, out var iconFunc))
            {
                return iconFunc();
            }
        }

        // Default icon if no match is found
        return new Icons.Regular.Size24.Document();
    }

    // Example methods for download and delete actions
    private async Task DownloadFile(FileModel file)
    {
        try
        {
            // Implement download logic here
        }
        catch (Exception ex)
        {
            // Handle exceptions and provide user feedback
            Console.Error.WriteLine($"Error downloading file {file.Name}: {ex.Message}");
            // Optionally, show a notification to the user
        }
    }

    private async Task DeleteFile(FileModel file)
    {
        try
        {

        }
        catch (Exception ex)
        {
            // Handle exceptions and provide user feedback
            Console.Error.WriteLine($"Error deleting file {file.Name}: {ex.Message}");
            // Optionally, show a notification to the user
        }
    }

    // Example FileModel
    public class FileModel
    {
        public string Name { get; set; }
        public long Size { get; set; }
        public string ContentType { get; set; }
    }

}

@code{
    private string GetUserEmail()
    {
        // Try to get the user's primary email from the Emails list
        if (profile?.Emails != null && profile.Emails.Any())
        {
            var primaryEmail = profile.Emails.FirstOrDefault();
            if (primaryEmail != null)
            {
                return primaryEmail.Address ?? accountInfo?.UserPrincipalName ?? "";
            }
        }
        // As a fallback, return accountInfo?.UserPrincipalName or an empty string
        return accountInfo?.UserPrincipalName ?? "";
    }
    
    private string GetUserFullName()
    {
        // Try to get the user's full name from the Names list
        if (profile?.Names != null && profile.Names.Any())
        {
            var primaryName = profile.Names.FirstOrDefault();
            if (primaryName != null)
            {
                string firstName = primaryName.First ?? "";
                string lastName = primaryName.Last ?? "";
                if (!string.IsNullOrWhiteSpace(firstName) || !string.IsNullOrWhiteSpace(lastName))
                {
                    return $"{firstName} {lastName}".Trim();
                }
                else if (!string.IsNullOrWhiteSpace(primaryName.DisplayName))
                {
                    return primaryName.DisplayName;
                }
            }
        }

        // As a fallback, return accountInfo?.UserPrincipalName or "User"
        return accountInfo?.UserPrincipalName ?? "User";
    }
      private string GetUserPhoneNumber()
    {
        // Try to get the user's primary phone number from the Phones list
        if (profile?.Phones != null && profile.Phones.Any())
        {
            // Look for the mobile phone number first
            var mobilePhone = profile.Phones.FirstOrDefault(phone => phone.Type == PhoneType.Mobile);
            if (mobilePhone != null && !string.IsNullOrWhiteSpace(mobilePhone.Number))
            {
                return mobilePhone.Number;
            }

            // If no mobile phone, get any available phone number
            var primaryPhone = profile.Phones.FirstOrDefault();
            if (primaryPhone != null && !string.IsNullOrWhiteSpace(primaryPhone.Number))
            {
                return primaryPhone.Number;
            }
        }

        // As a fallback, return an empty string or a default message
        return "";
    }
      private string GetUserAddress()
    {
        // Try to get the user's current position from the Positions list
        if (profile?.Positions != null && profile.Positions.Any())
        {
            // Look for the current position where IsCurrent is true
            var currentPosition = profile.Positions.FirstOrDefault(position => position.IsCurrent == true);

            if (currentPosition != null && currentPosition.Detail?.Company?.Address != null)
            {
                var address = currentPosition.Detail.Company.Address;

                // Extract address components
                string street = address.Street ?? "";
                string city = address.City ?? "";
                string state = address.State ?? "";
                string postalCode = address.PostalCode ?? "";
                string countryOrRegion = address.CountryOrRegion ?? "";

                // Build the full address string
                var addressParts = new List<string> { street, city, state, postalCode, countryOrRegion };
                var fullAddress = string.Join(", ", addressParts.Where(part => !string.IsNullOrWhiteSpace(part)));

                if (!string.IsNullOrWhiteSpace(fullAddress))
                {
                    return fullAddress;
                }
            }
        }

        // As a fallback, return a default message or an empty string
        return "Address not specified";
    }
      private string GetUserLanguage()
    {
        // Try to get the user's primary language from the Languages list
        if (profile?.Languages != null && profile.Languages.Any())
        {
            var primaryLanguage = profile.Languages.FirstOrDefault();
            if (primaryLanguage != null)
            {
                string displayName = primaryLanguage.DisplayName ?? "";
                string tag = primaryLanguage.Tag ?? "";

                if (!string.IsNullOrWhiteSpace(displayName))
                {
                    return displayName;
                }
                else if (!string.IsNullOrWhiteSpace(tag))
                {
                    return tag;
                }
            }
        }

        // As a fallback, return a default message or an empty string
        return "Language not specified";
    }


    private string ParseAndFormatDateTime(string? dateTimeString)
    {
        if (string.IsNullOrEmpty(dateTimeString))
            return "N/A";

        if (DateTime.TryParse(dateTimeString, out DateTime dateTime))
        {
            return dateTime.ToLocalTime().ToString("g");
        }

        return dateTimeString; // Return the original string if parsing fails
    }
}